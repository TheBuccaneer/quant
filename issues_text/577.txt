Take the phase_estimation.cpp example 
```cpp
struct r1PiGate {
  void operator()(cudaq::qubit &q) __qpu__ { r1(1., q); }
};

int main() {

  for (auto nQubits : std::vector<int>{2, 4, 6, 8}) {
    auto counts = cudaq::sample(
        qpe{}, nQubits, [](cudaq::qubit &q) __qpu__ { x(q); }, r1PiGate{});
    auto mostProbable = counts.most_probable();
    double theta = cudaq::to_integer(mostProbable) / (double)(1UL << nQubits);
    auto piEstimate = 1. / (2 * theta);
    printf("Pi Estimate(nQubits == %d) = %lf \n", nQubits, piEstimate);
  }
}
```
As is, if compiled targeting the `RemoteRESTQPU`, this works 
```bash 
nvq++ --target quantinuum --emulate phase_estimation.cpp
./a.out
```

However, if I just add a couple more kernel lambdas, even if unused, 
```cpp 

struct r1PiGate {
  void operator()(cudaq::qubit &q) __qpu__ { r1(1., q); }
};

int main() {

  auto statePrep = [](cudaq::qubit &q) __qpu__ { x(q); };
  auto oracle = [](cudaq::qubit &q) __qpu__ { r1(1., q); };

  for (auto nQubits : std::vector<int>{2, 4, 6, 8}) {
    auto counts = cudaq::sample(
        qpe{}, nQubits, [](cudaq::qubit &q) __qpu__ { x(q); }, r1PiGate{});
    auto mostProbable = counts.most_probable();
    double theta = cudaq::to_integer(mostProbable) / (double)(1UL << nQubits);
    auto piEstimate = 1. / (2 * theta);
    printf("Pi Estimate(nQubits == %d) = %lf \n", nQubits, piEstimate);
  }
}
```
This fails because no counts come back due to the execution going through Library Mode and the ExecutionManager. The Quake gets generated, but there must be some issue with overriding the original entry point function. Perhaps the signatures are wrong somehow. 