Project,IssueID,URL,Title,Status,CreatedAt,BugType ,StackLayer,CTClass,subtype,DUB,reason Bug,reason Stack,reason Class
NVIDIA/cuda-quantum,3433,https://github.com/NVIDIA/cuda-quantum/issues/3433,Can not pip install cudaq on Ubuntu 22.04,open,2025-09-10T22:11:20Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,B ,B1,,The PyPI cudaq source distributions are published with broken package metadata where the project name is reported as unknown ,The problem lives in the build pipeline for Python (pyproject),A packaging linter or CI step that validates the built Wheel metadata could detect this mismatch deterministically before Publishing. Fits  B1
NVIDIA/cuda-quantum,2937,https://github.com/NVIDIA/cuda-quantum/issues/2937,Wrong simulation result with the tensornet/tensornet-mps target,closed,2025-05-21T06:22:52Z,Performance-/Numerik-Bug ,Backend-Library ,C,,,"For this specific highly structured 20-qubit circuit, the tensornet and tensornet-mps targets return a sample distribution that only contains 8 bitstrings instead of the 16 bitstrings ",The issue is confined to the tensor-network simulation backend. It is located in the Cuda-Q backend library. ,It is a numerical or algorithmic error in the backend logic. Therefore it cannot be detected at compile time.
NVIDIA/cuda-quantum,2641,https://github.com/NVIDIA/cuda-quantum/issues/2641,Testing regression introduced with python/tests/kernel/test_explicit_measurements.py,closed,2025-02-20T18:10:53Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment,B ,B1,,A change introduced in PR #2567 broke the Python test python/tests/kernel/test_explicit_measurements.py,The problem is the test harness and its target discovery logic that are incorrect for partial builds. Cuda-Q Kernel seem fine,"This is a configuration problem, which could be solved with a configuration check. Skipping the config could help. Fits B1 "
NVIDIA/cuda-quantum,2628,https://github.com/NVIDIA/cuda-quantum/issues/2628,using cudaq.State and mqpu backend to run two independent circuit gives error,open,2025-02-17T20:35:00Z,Backend-/Framework-Integrations-Bug,Runtime-Framework-Runtime,C,,,"When the user prepares two cudaq.State objects from CuPy data and runs the same kernel on the nvidia target with option=""mqpu"" using sample_async on qpu_id=0 and qpu_id=1, the program aborts with ubackend::RuntimeError: cudaErrorIllegalAddress",The issue is rooted in the CUDA-Q backend. This points to abug in backend library. ,Illegal device address at runtime is low level memory management. 
NVIDIA/cuda-quantum,2627,https://github.com/NVIDIA/cuda-quantum/issues/2627,List of list in kernel argument gives error,open,2025-02-17T16:38:51Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,1809,"When the kernel is declared with a nested Python type annotation and called with a list-of-lists argument, CUDA-Q fails at runtime with RuntimeError","The problem resides in the high-level Python language binding and its type-mapping layer. Kernel call uses  Python syntax, but Cuda-Q does not support this.",We could use a expressive static type checker for rejecting unsupported nested container types. This could be done at compile time.
NVIDIA/cuda-quantum,2625,https://github.com/NVIDIA/cuda-quantum/issues/2625,[Python][MLIR?] Loop miscompilation,closed,2025-02-17T15:45:17Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,B ,B2,,Compiling the bar kernel crashes with an LLVM/MLIR assertion. ,The problem is in the Cuda-Q compiler / MLIR backend. ,"A robust IR verifier running after control flow transformation could detected that mlir::value with no attached result is being treated as an OpResult. This requieres IR level validation. Not simple compile time check, so B2"
NVIDIA/cuda-quantum,2608,https://github.com/NVIDIA/cuda-quantum/issues/2608,The bridge failing to deal with captured globals.,open,2025-02-11T12:18:59Z,API-/Usage-/Logic-Bug (High-Level),Framework-Integration,B ,B2,,The Python Q bridge records it in the symbol table as !cc.ptr<f64> instead of plain f64,The problem lies in the framework integration layer. ,Could possibly be resolved with data flow manager with capturied symbols to verify statically the globals used as scalar parameters. Fits B2 
NVIDIA/cuda-quantum,2600,https://github.com/NVIDIA/cuda-quantum/issues/2600,Return list[complex] fails when returning list[float],closed,2025-02-07T15:17:46Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,,error: type of return operand 0 ('!cc.stdvec<f64>') doesn't match function result type ('!cc.stdvec<complex<f64>>') in function @__nvqpp__mlirgen__myop,"Usere code is syntactivally valid, but the bridge does not reconcile the list annoation with a float-valued list literal.", more advanced static type checker could be used for the front-end. It could detect return expression has ceratin type. Match this class A
NVIDIA/cuda-quantum,2593,https://github.com/NVIDIA/cuda-quantum/issues/2593,cannot use @cudaq.kernel in the interpreter: OSError: could not get source code,open,2025-02-06T16:42:27Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"When the user types the @cudaq.kernel example from the official VQE tutorial directly into an interactive Python interpreter, the decorator fails",The failure occurs entirely in the high-level Python API. No backend simulation or procedure is involved.,Bug seems to be limited at at specific interpreter environment and is bound to Python semantics. How to rule out this at compile time? Class C
NVIDIA/cuda-quantum,2575,https://github.com/NVIDIA/cuda-quantum/issues/2575,custom gate register_operation doesn't seem to work if it is invoked in one kernel which is nested in another.,open,2025-02-02T19:37:34Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"A custom matrix gate registered via cudaq.register_operation(""my_gate"", my_matrix) can be called in a kernel, but calling it through a nested kernel is ignored",It seems like the problem is in the Python Framework integration that connects custom registered operations into kernel call graphs.,"Hard to impossible to validate, because detecting requieres reasoning which is not simply checked at compile time. Fits C "
NVIDIA/cuda-quantum,2560,https://github.com/NVIDIA/cuda-quantum/issues/2560,Input argument to a kernel throws an error,open,2025-01-30T16:21:31Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,A,,,"A kernel with def kernel(list) cannot be called with a = [(1,2)]. The Python bridge raises an error while trying to interpret the list. ",Parses annotations and builds python to Q type mapping. Seems to be high level Python API to framework mapping problem.,A stronger static checker for the Python fron-end could detect that list of touples is an unsupported operation. Fits A
NVIDIA/cuda-quantum,2550,https://github.com/NVIDIA/cuda-quantum/issues/2550,[Python] Noise channels don't respect single/double precision setting of the target,closed,2025-01-28T00:33:22Z,Performance-/Numerik-Bug,Backend-Library,C,,,"In NoiseModel.h, kraus_op data is templated (cudaq::complex). However, when generating Python binding (py_NoiseModel.cpp), this is compiled only with double precision config. This caused bogus Kraus channel data for single-precision targets, e.g., when the channel is created in Python with cudaq.KrausChannel",It is a classic backend library config problem for the Python binings. Model templates and their Python exposure seem to be inconsistent.,Needs verification that c or cpp File is built for both float and double. Underlying issue is numeric implementation error.
NVIDIA/cuda-quantum,2541,https://github.com/NVIDIA/cuda-quantum/issues/2541,Python ast bridge and kernel builder do not properly annotate kernels,closed,2025-01-24T21:20:06Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,B ,B2,, A kernel function must be annotated with the cudaq-kernel attribute. Python doesn't do this making proper identification of kernel functions impossible,"Python front end generates Q-IR, bridge omits the kernel annotation in the produced metadata, independent of backend simulator or environment.",metadata validator could check any callable exposed as Cuda-Q kernel carries the cudaq-kernel attribute and flag missing annotations before compilation. Would requiere lots of effort with metadata checks. 
NVIDIA/cuda-quantum,2540,https://github.com/NVIDIA/cuda-quantum/issues/2540,Python AST Builder assigns quantum memory artifacts to classic memory locations,closed,2025-01-24T21:10:55Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,B ,B2,,"Lowering generiert ein Muster, das Quanten-Referenzen in ein klassisches Array kopiert, was laut IR-Semantik verboten ist.","Backend-Library"": Das Problem liegt in den Codegen-/Optimizer-P�ssen f�r Quake/CC-IR, nicht im User-Frontend.","(potenziell compile-time vermeidbar, fortgeschrittene Analyse)"": Ein IR-Verifier k�nnte verbieten, dass quake.ref in klassische Datenstrukturen gespeichert wird (lokales Pattern, aber spezieller Check n�tig)."
NVIDIA/cuda-quantum,2538,https://github.com/NVIDIA/cuda-quantum/issues/2538,Python kernel builder uses empty strings for measurement names,closed,2025-01-24T20:04:52Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,A,,,"Python-Kernel-Builder erzeugt Mess-Operationen mit leerem Namen, obwohl dies in der IR als illegal definiert ist.","Fehler sitzt im High-Level-Builder, der ung�ltige IR erzeugt.","Ein einfacher lokaler Check ""Name darf nicht leer sein"" im Builder oder IR-Verifier w�rde dieses Pattern deterministisch verhindern."
NVIDIA/cuda-quantum,2536,https://github.com/NVIDIA/cuda-quantum/issues/2536,Compile error when using `cudaq::adjoint` on quantum kernels with non-trivial `for` loop conditions,open,2025-01-24T14:47:30Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,C,,,Aus User-Sicht korrekte Schleifen (z.B. i < size-1 oder while (i < size)) lassen sich nicht adjungieren und f�hren zu Compilerfehlern/Crashes.,"Problem stammt aus den MLIR/CFG-/Adjoint-P�ssen im Compiler, nicht aus Umgebung oder Backend-Auswahl.","Fehlende Unterst�tzung bestimmter Kontrollflussformen in der Adjoint-Pipeline ist ein Compiler-Implementierungsproblem, das nicht durch Zusatzchecks am Usercode vermieden werden kann."
NVIDIA/cuda-quantum,2525,https://github.com/NVIDIA/cuda-quantum/issues/2525,cudaq.control() doesn't work with exp_pauli(),closed,2025-01-21T17:57:24Z,Performance-/Numerik-Bug ,Backend-Library ,C,,1894,"The circuit perform the exp_pauli() on both the |0> and the |1> subspaces on the state. If I instead, perform a cudaq.control() with a different gate, say Ry(), I get the correct result. ",The problem resides in the backend library’s implementation of exp_pauli and its interaction with cudaq.control for controlled multi-qubit exponentials,This is a semantic error in the backend’s numerical logic for controlled exp_pauli. It cannot be ruled out by generic compile-time or static type checks and requires runtime validation
NVIDIA/cuda-quantum,2457,https://github.com/NVIDIA/cuda-quantum/issues/2457,`mx` operation unsupported in OpenQASM conversion,closed,2024-12-09T19:27:09Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Currently, a CUDA-Q kernel containing the mx measurement operation cannot be translated into OpenQASM 2.0 via cudaq.translate()",Possible error in integration btw Cuda-Qs Quake IR and the OpenQASM 2 backend.,a static checker couldn't generally know which operations a given translation backend supports
NVIDIA/cuda-quantum,2453,https://github.com/NVIDIA/cuda-quantum/issues/2453,Float comparison operator throws throws error in cudaq.kernel,closed,2024-12-05T21:43:47Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,B ,B2,,"Attempting to use comparison operators like < throws an error in a cudaq.kernel. Used kernel is a = 0.5 < 1.0. This will throw: error: 'arith.cmpi' op operand #0 must be signless-integer-like, but got 'f64' ","the high-level kernel code is valid Python, but the bridge emits an arith.cmpi op with the wrong type constraints ",A IR validator or operator-compatibility check could statically flag that float operands are being fed to an integer-only compare op 
NVIDIA/cuda-quantum,2452,https://github.com/NVIDIA/cuda-quantum/issues/2452,Error not thrown when broadcasting custom unitary to a qvector.,open,2024-12-05T19:24:02Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,,"When attempting to broadcast a custom unitary to a qvector, an error is not thrown. In the reproducer below, the kernel produces an incorrect result when sampled. ",The issue is in the high-level Python API / kernel-call that wires cudaq.qvector arguments into registered custom operations ,A front-end checker could statically compare the arity implied by the custom-op matrix with the argument shape 
NVIDIA/cuda-quantum,2434,https://github.com/NVIDIA/cuda-quantum/issues/2434,cudaErrorIllegalAddress error when using exp_pauli(...) on multiple GPUs,open,2024-11-28T15:14:43Z,Performance-/Numerik-Bug,Backend-Library,C,,,"When using exp_pauli(pauli string) in a kernel, cudaq.observe(...) and cudaq.sample(...) calls result in the error:  RuntimeError: cudaErrorIllegalAddress ",Error arises in the CUDA-Q backend library that implements multi-GPU execution of exp_pauli. ,Illegal address on the GPU is a low-level runtime bug. Nothing which could be detected reasonably within compiletime
NVIDIA/cuda-quantum,2425,https://github.com/NVIDIA/cuda-quantum/issues/2425,[braket] Reorder global register to be in original qubit allocation order,open,2024-11-27T01:25:48Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Reorder global register to be in original qubit allocation order for braket backend, if we run any qubit mapping. ",A framework integration issue in the Braket backend’s mapping layer. Cuda-Q kernel and API seem to be fine.  ,Whether a backend reorders qubits after mapping is a backend-specific integration detail. A generic compile-time checker on user code cannot easily see or forbid this.
NVIDIA/cuda-quantum,2415,https://github.com/NVIDIA/cuda-quantum/issues/2415,Failure when building `OptTransforms` library alone.,closed,2024-11-25T19:12:49Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment,B ,B1,,Teil-Build von OptTransforms erzeugt fehlende generierte Header nicht und schl�gt beim Kompilieren fehl.,"Fehler tritt im CMake/Ninja-Buildprozess auf, bevor irgendetwas ausgef�hrt wird.","(potenziell compile-time vermeidbar, fortgeschrittene Analyse)"": Ein Build-System-Check k�nnte gezielt pr�fen, ob alle generierten Includes korrekt als Abh�ngigkeiten angelegt sind."
NVIDIA/cuda-quantum,2306,https://github.com/NVIDIA/cuda-quantum/issues/2306,Unified memory support on GH200 Grace Hopper,closed,2024-10-21T16:49:29Z,Performance-/Numerik-Bug ,Backend-Library,C,,,"Simulation scheitert mit ""requested size is too big"", obwohl Hardware mit Unified Memory eigentlich mehr Qubits erlauben sollte.","Limitierung entsteht durch cuQuantum-/Backend-Speicherallokation (z.B. cudaMalloc vs. cudaMallocManaged), nicht durch User-Code oder Build.","Nutzung von Unified Memory ist ein Implementierungs-/Architekturthema des Backends, das sich nicht durch User-seitige Compile-Time-Checks ""vermeiden"" l�sst."
NVIDIA/cuda-quantum,2279,https://github.com/NVIDIA/cuda-quantum/issues/2279,Inconsistent behavior with mid-circuit measurements while sampling if NO reset is performed after the measurement,open,2024-10-14T22:58:54Z,Performance-/Numerik-Bug,Backend-Library,C,,,"emantisch identische Kernels liefern unterschiedliche __global__-Verteilungen, weil Mid-Circuit-Meas den State nicht kollabiert.","Ursache liegt in der Implementierung der Simulatoren (bis auf stim), die Mid-Circuit-Meas falsch modellieren.",Das ist eine grundlegende Simulations-Semantikfrage und nur durch �nderung der Simulator-Implementierungen l�sbar.
NVIDIA/cuda-quantum,2274,https://github.com/NVIDIA/cuda-quantum/issues/2274,Erroneous mid-circuit measurements while sampling if a reset is performed after the measurement,closed,2024-10-14T15:30:10Z,Performance-/Numerik-Bug,Backend-Library,C,,,Mid-circuit measurements are being reported with incorrect values if a reset follows them. I believe this affects all of the existing simulators. ,The problem sits in the simulator backend. the reset implementation does not flush pending sampling tasks ,Whether the simulator correctly flushes its internal sampling queue on reset is purely a runtime implementation detail 
NVIDIA/cuda-quantum,2271,https://github.com/NVIDIA/cuda-quantum/issues/2271,Mid-circuit measurements are not handled properly when using `__qpu__` attributes on C++ functions or lambdas,open,2024-10-14T00:40:22Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Runtime kann Funktionsnamen von __qpu__-Kernels nicht aufl�sen, daher werden Mid-Circuit-Conditionals falsch behandelt","Problem sitzt im Zusammenspiel von Compiler-/QIR-Metadata und Runtime (kernelHasConditionalFeedback), nicht in User-API oder Backend-Kern.","Ob Kernel-Namen korrekt im Runtime-Metadaten-Map landen, ist eine interne Integrationsfrage und nicht durch statische Analyse des Usercodes vermeidbar."
NVIDIA/cuda-quantum,2249,https://github.com/NVIDIA/cuda-quantum/issues/2249,anyon target is not stable in CI,closed,2024-10-03T20:05:12Z,Performance-/Numerik-Bug,Backend-Library,C,,,"Mid-Circuit-Register bleibt immer 00000, weil Sampling-/Reset-Logik im Simulator nicht korrekt miteinander interagiert.","Bug liegt in den Simulator-Implementierungen (resetQubit / Sampling-Tasks), die alle Targets betreffen.",Korrekte Behandlung von Reset + Sampling ist Teil der Simulator-Algorithmik und nicht durch zus�tzliche User-seitige Compile-Time-Checks abfangbar.
NVIDIA/cuda-quantum,2240,https://github.com/NVIDIA/cuda-quantum/issues/2240,List defined inside a kernel passed into subkernel throws an error,open,2024-10-01T12:25:32Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Die Draw-Funktion interagiert mit dem custatevec-Pfad so, dass exp_pauli einen Initialisierungsfehler ausl�st, obwohl sample funktioniert."," Problem im Zusammenspiel von High-Level-Kernel/Draw-API und Backend-/Library-Aufruf, nicht im User-Kernel selbst.",ehler liegt in der konkreten Implementierung des Draw-/Backend-Pfads und l�sst sich nicht durch zus�tzliche statische Checks am User-Code verhindern.
NVIDIA/cuda-quantum,2196,https://github.com/NVIDIA/cuda-quantum/issues/2196,FuseWithConstantArray on ExtractValueOp always returns success(),closed,2024-09-06T16:20:11Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,B ,B2,,"Der MLIR-Pass gibt ""success"" zur�ck, obwohl kein Pattern angewendet wurde, und blockiert damit weitere Canonicalization-Patterns.","Bug sitzt im Compiler-/Optimizer-Pass der Quake/CC-IR, nicht in User-API oder Umgebung.","Ein IR-/Pass-Validator k�nnte die Inkonsistenz ""Erfolg ohne �nderung"" statisch finden; das erfordert aber spezielle Compiler-Analysen, nicht nur einfache Typchecks."
NVIDIA/cuda-quantum,2185,https://github.com/NVIDIA/cuda-quantum/issues/2185,`nvidia` target: simulation errors when setting `CUDAQ_MAX_CPU_MEMORY_GB` beyond system memory capacity,open,2024-09-02T04:18:07Z,Config-/Environment-Bug,Runtime-/Framework-Runtime ,C,,,"Dokumentierte Umgebungsvariable verh�lt sich f�r ""unlimited"" oder zu gro�e Werte nicht robust und f�hrt zu Laufzeitfehlern / falschen Resultaten.","Fehler liegt in der Laufzeitlogik, wie die Simulatoren Host-/GPU-Speichergrenzen interpretieren, nicht in Build oder User-API.",Die Relation zwischen physischem Speicher und Konfiguration der Runtime ist nicht �ber Analyse des Usercodes abfangbar; n�tig ist robustere Runtime-Implementierung.
NVIDIA/cuda-quantum,2157,https://github.com/NVIDIA/cuda-quantum/issues/2157,Drawing conditional measurement operations,open,2024-08-27T09:28:43Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,ie Zeichnen-Funktion ignoriert bedingte Gates basierend auf Messergebnissen und verletzt damit die erwartete Visualisierungs-Semantik.,"Fehler liegt in der High-Level-Darstellungs-/Visualisierungslogik, unabh�ngig von Backend und Numerik.","Das Problem ist fehlende Funktionalit�t der Draw-API; Compile-Time-Checks am Kernel-Code k�nnen das nicht ""verhindern"", nur die Implementierung selbst kann es beheben."
NVIDIA/cuda-quantum,2110,https://github.com/NVIDIA/cuda-quantum/issues/2110,C++ segfault when passing callable kernel to another kernel from library,open,2024-08-19T23:22:46Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Das Pattern ""Kernel in lib.cpp, Aufruf �ber std::function in user.cpp"" ist aus C++-Sicht legitim, f�hrt aber in CUDA-Q zu einem Laufzeitcrash.","Problem sitzt in der Art, wie das Runtime-/Compiler-System Kernel-Symbole �ber �bersetzungseinheiten und Funktionsobjekte hinweg behandelt.",Hier fehlt Unterst�tzung in der Toolchain/Runtime; zus�tzliche statische Checks am Usercode w�rden eher einschr�nken als sinnvoll vermeiden.
NVIDIA/cuda-quantum,2092,https://github.com/NVIDIA/cuda-quantum/issues/2092,Incorrect spin op expression evaluation,closed,2024-08-14T20:18:13Z,Performance-/Numerik-Bug,Backend-Library,C,,,"Die generierte Matrix f�r die Operator-Kombination ist falsch, w�hrend die umgekehrte Reihenfolge korrekt ist.",Ursache ist ein Fehler in der Implementierung der Spin-Operator-Algebra / Matrixkonstruktion.,"Das ist ein reiner Algebra-/Implementierungsbug, der nicht durch statische Analyse des Usercodes verhindert werden kann."
NVIDIA/cuda-quantum,2088,https://github.com/NVIDIA/cuda-quantum/issues/2088,Target tests appear to sometimes use files from installation directory,closed,2024-08-13T17:04:14Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment,B ,B1,,Targettests h�ngen implizit von einem vorherigen make install ab und testen damit nicht konsistent den aktuellen Build.," Problem liegt in CMake/Test-Konfiguration (Pfad-/RPATH-/Suchreihenfolge), nicht in Laufzeit oder Kerneln.","Eine strengere Build-/Test-Validierung k�nnte pr�fen, ob Tests wirklich die im Build-Verzeichnis erzeugten Artefakte verwenden."
NVIDIA/cuda-quantum,2076,https://github.com/NVIDIA/cuda-quantum/issues/2076,`qvector` initialization from state does not work unless no other qubits have been allocated yet,closed,2024-08-12T13:13:51Z,Performance-/Numerik-Bug,Backend-Library,C,,,"Initialisierung von q = cudaq.qvector(vec) beeinflusst unerwartet das vorgelagerte Qubit p, sodass die Messverteilung falsch ist.","Fehler in der Implementierung der State-Init-Routinen der nvidia-*-Backends, nicht in API-Usage oder Build.",Korrektheit der Statepr�paration ist reine Backend-Algorithmik und l�sst sich praktisch nicht durch Typ-/Contract-Checks am User-Kernel absichern.
NVIDIA/cuda-quantum,1975,https://github.com/NVIDIA/cuda-quantum/issues/1975,Synthesis fails for some kernels that use `cudaq::slice_vector`,closed,2024-07-19T20:59:04Z,API-/Usage-/Logic-Bug (High-Level),Framework-Integration,C,,,"Nutzung von slice_vector/observe erzeugt IR, die der Synthesizer/NVQC-Pfad nicht unterst�tzt.",Bug im Zusammenspiel zwischen CUDA-Q-Frontend (Pointer-/Slice-API) und der nachgelagerten Synthese-/NVQC-Infrastruktur.,"Das ist ein L�cken-/Kompatibilit�tsproblem im Synthesizer; zus�tzliche Analysen des Usercodes w�rden es nicht vermeiden, sondern nur fr�here Fehlermeldungen erzeugen."
NVIDIA/cuda-quantum,1957,https://github.com/NVIDIA/cuda-quantum/issues/1957,[MLIR mode] Compile error for `pauli_word` argument,closed,2024-07-18T05:53:38Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"In MLIR mode, compiling a kernel that takes a cudaq::pauli_word and passes it to exp_pauli(theta, q, pauli) fails with error: could not determine string argument",Issue is probably in the compiler and not API misuse or backend simulation.,Would need a type validator for the MLIR path. Advanced knowledge and implementation in combination with specialised compiler-level analysis instead of some kind of type checking
NVIDIA/cuda-quantum,1946,https://github.com/NVIDIA/cuda-quantum/issues/1946,current version of cudaq.draw throws error if kernel uses exp_pauli,closed,2024-07-17T16:47:33Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Semantisch korrekter Aufruf mit cudaq::pauli_word wird vom Compiler als ""could not determine string argument"" abgewiesen.","Ursache ist ein Fehler im MLIR-/Codegen-Pfad f�r exp_pauli mit pauli_word, nicht in der API-Nutzung oder Umgebung.","Es fehlt eine Implementierung/�berladung im Compiler; das ist keine Situation, die man mit st�rkeren Typ-/Contract-Checks am User-Code sinnvoll ""vermeiden"" k�nnte."
NVIDIA/cuda-quantum,1925,https://github.com/NVIDIA/cuda-quantum/issues/1925,[CI] [tensornet] Attempt to set target causes fatal error in some OS environments,open,2024-07-12T23:03:00Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Test, der alle Targets parametrisiert durchl�uft, bringt CI-L�ufe zum Crash, wenn optionale Simulatoren nicht korrekt verf�gbar/integrated sind.","Problem liegt im Zusammenspiel von Test-Infrastruktur, set_target und optionalen Backends in unterschiedlichen OS-/CI-Umgebungen.",Hier geht es um robuste Implementierung von Target-Erkennung/-Fehlerbehandlung in Code und CI; das l�sst sich nicht sinnvoll durch zus�tzliche Compile-Time-Analysen der User-Kernels verhindern.
NVIDIA/cuda-quantum,1924,https://github.com/NVIDIA/cuda-quantum/issues/1924,[Python] Remote execution speed up doesn't support custom operations,open,2024-07-12T21:51:44Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Lokale Registrierung von custom_h funktioniert, aber Remote-Server meldet ""known kernels are []"" und kann den Kernel nicht ausf�hren.",Fehler sitzt in der Integration zwischen Python-Frontend/Custom-Op-Registry und Remote-Execution-Service.,"Ob Custom-Operationen korrekt zum Remote-Backend transportiert/registriert werden, ist eine Integrationsfrage und nicht durch statische Analyse des User-Codes abfangbar."
NVIDIA/cuda-quantum,1909,https://github.com/NVIDIA/cuda-quantum/issues/1909,cudaq.observe causes a memory leak,closed,2024-07-10T05:34:33Z,Performance-/Numerik-Bug,Runtime-/Framework-Runtime ,C,,,peichernutzung w�chst bei vielen observe-Aufrufen kontinuierlich und wird nicht freigegeben.,"Problem liegt im Ressourcen-/Speichermanagement der Runtime/Execution-Engine, nicht im Compiler oder in der API-Semantik.",Speicherlecks dieser Art sind klassische Runtime-Implementierungsbugs und nicht durch Compile-Time-Analysen des User-Programms zu verhindern.
NVIDIA/cuda-quantum,1895,https://github.com/NVIDIA/cuda-quantum/issues/1895,Endian is inconsistent between State and SpinOperator.to_matrix,closed,2024-07-08T07:26:25Z,Performance-/Numerik-Bug,Backend-Library ,C,,,Erwartungswert aus observe und direkte Berechnung state @ to_matrix() @ state liefern unterschiedliche Ergebnisse wegen unterschiedlicher Endianness-Konvention.,Fehler liegt in der Implementierung von SpinOperator.to_matrix bzw. der Zuordnung von Operator zu Zustandsbasis.,Inkonsequente Endianness ist ein Design-/Implementierungsfehler in der Library und l�sst sich nicht durch statische Analyse von User-Kernels vermeiden.
NVIDIA/cuda-quantum,1894,https://github.com/NVIDIA/cuda-quantum/issues/1894,Controlled exp_pauli is not correct,closed,2024-07-08T07:08:46Z,Performance-/Numerik-Bug ,Backend-Library ,C,,2525,DOUBLE,DOUBLE,DOUBLE 
NVIDIA/cuda-quantum,1875,https://github.com/NVIDIA/cuda-quantum/issues/1875,issue with if condition after mid circuit measurement,closed,2024-07-01T15:17:07Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,C,,,"Semantisch �quivalente Kontrolllogik mit and und verschachtelten if-Statements f�hrt zu unterschiedlichem Verhalten, a wird im zweiten Fall nicht gesetzt.","Ursache ist die Codegen-/Lowering-Logik f�r boolesche Ausdr�cke und Mess-Ergebnisse, nicht Environment oder Backend-Selection."," Das ist ein Compiler-/IR-Lowering-Bug; zus�tzliche statische Checks am User-Kernel w�rden ihn nicht verhindern, nur Implementierungsfixes im Codegen."
NVIDIA/cuda-quantum,1874,https://github.com/NVIDIA/cuda-quantum/issues/1874,Execution hangs on OpenSUSE when installed via installer,closed,2024-07-01T13:16:37Z,Performance-/Numerik-Bug,Runtime-/Framework-Runtime ,C,,,Ausf�hrung auf GPU-Backends unter OpenSUSE blockiert bzw. l�uft nur nach Timeout weiter.,Problem liegt in der Interaktion von CUDA-Q-Runtime mit libc++/OS-spezifischer Umgebung beim Starten/Ausf�hren der GPU-Backends.,OS-/Runtime-spezifische H�nger dieser Art sind Implementierungs-/Konfigurationsdetails der Runtime und nicht durch zus�tzliche Compile-Time-Analysen am User-Code vermeidbar.
NVIDIA/cuda-quantum,1871,https://github.com/NVIDIA/cuda-quantum/issues/1871,Calling the same quantum kernel in cudaq.control and cudaq.adjoint in the main kernel give error.,closed,2024-06-30T13:35:07Z,API-/Usage-/Logic-Bug (High-Level),Framework-Integration ,C,,,"
BugType - 1.4 ""API-/Usage-/Logic-Bug (High-Level)"": Aus User-Sicht legitime Kombination von kontrolliertem und adjungiertem Kernel f�hrt zu ""does not reference a valid function"".",,"Ursache ist die MLIR/Codegen-Behandlung von adjungierten/kontrollierten Funktionssymbolen, nicht Python-Usage oder Environment."
NVIDIA/cuda-quantum,1860,https://github.com/NVIDIA/cuda-quantum/issues/1860,Build dependency missing for python?,closed,2024-06-27T20:45:25Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,B ,B1,,suspect that there may be missing boilerplate regarding copying the .py files in our cmake recipes. ,This is a build / environment configuration issue in the CUDA-Q installation flow ,"A simple configure-time check in CMake could fix this problem, so B1"
NVIDIA/cuda-quantum,1813,https://github.com/NVIDIA/cuda-quantum/issues/1813,DepolarizationChannel not completely depolarizing,closed,2024-06-13T16:47:35Z,Performance-/Numerik-Bug,Backend-Library,C,,,"Depolarisierender Kanal mit Fehlerwahrscheinlichkeit 1 erzeugt <Z>-Erwartungswerte, die vom Rotationswinkel abh�ngen statt 0 zu sein.","Fehler liegt in der Implementierung von DepolarizationChannel bzw. density-matrix-cpu, nicht in der High-Level-API.",Falsche Kanal-Semantik ist ein reiner Implementierungs-/Numerik-Bug im Simulator und l�sst sich nicht durch Typ-/Contract-Checks am User-Code verhindern.
NVIDIA/cuda-quantum,1809,https://github.com/NVIDIA/cuda-quantum/issues/1809,Kernels do not take as input a list[list[int]] type object,open,2024-06-13T15:57:42Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,2627,DOUBLE,DOUBLE,DOUBLE
NVIDIA/cuda-quantum,1804,https://github.com/NVIDIA/cuda-quantum/issues/1804,[python] Combining `cudaq` module with `multiprocesssing` module can result in deadlock,closed,2024-06-12T14:30:28Z,Config-/Environment-Bug,Runtime-/Framework-Runtime ,C,,,Verwendung des default-Startverfahrens fork mit einem multithreaded CUDA-Q-Prozess f�hrt zu Deadlock.,"Problem entsteht in der Laufzeitinteraktion von Python-Process-Startmethode und CUDA-Q-Runtime, nicht im Build oder Kernel-Code.","Fork-vs-Spawn-Probleme bei Multithreading sind typische Runtime-/Systemeffekte, die nicht sinnvoll durch statische Analyse des User-Programms verhindert werden k�nnen."
NVIDIA/cuda-quantum,1799,https://github.com/NVIDIA/cuda-quantum/issues/1799,Incorrect circuit compilation when using some nested loops,closed,2024-06-11T11:24:06Z,API-/Usage-/Logic-Bug (High-Level),Backend-Library,C,,,"Decorator-Pfad kompiliert verschachtelte Schleifen mit for k in range(j+1, N) zu einem logisch falschen Circuit.","Ursache ist ein LLVM/MLIR-Codegen-/Loop-Normalization-Bug im Compiler-Pipeline, nicht im Python-Frontend oder in der Umgebung.","(nicht sinnvoll compile-time vermeidbar)"": Miscompilation durch Upstream-Loop-P�sse l�sst sich praktisch nur durch Fixes/Mitigations im Compiler beheben, nicht durch zus�tzliche Typ-/Contract-Checks am User-Code."
NVIDIA/cuda-quantum,1784,https://github.com/NVIDIA/cuda-quantum/issues/1784,Quake.ExpPauliOp is incomplete,open,2024-06-10T15:34:46Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,Die Klasse ExpPauliOp verhält sich bei Copy/Move/Assignment nicht wie eine saubere Value-Type-API – das ist ein objekt-/API-semantischer Bug. ,"ExpPauliOp ist Teil der High-Level-Operator-API; betroffen ist deren Implementierung, nicht Backend oder Umgebung. ","Fehlerhafte Value-Semantik in einer Library-Klasse wird nicht durch Analyse des Usercodes verhindert, sondern nur durch Korrektur der Klassenimplementierung. "
NVIDIA/cuda-quantum,1749,https://github.com/NVIDIA/cuda-quantum/issues/1749,`do { ... } while (false)` causes infinite loop when `--enable-mlir` is set,closed,2024-06-03T16:04:49Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,C ,,,Using the common macro pattern do { ... } while (0) inside a __qpu__ kernel causes programs compiled with nvq++ --enable-mlir to hang at runtime,"Issue seems to be in the MLIR-based compilation / backend path of CUDA-Q. the kernel is valid C++ code, but only the MLIR-enabled pipeline produces IR that leads to an apparent infinite loop during execution ",Whether this specific do { ... } while (0) pattern is lowered correctly depends on internal MLIR control-flow handling. Generic frontend type checker on code would not catch this
NVIDIA/cuda-quantum,1726,https://github.com/NVIDIA/cuda-quantum/issues/1726,Cannot call C++ __qpu__ function from within another kernel if parameters contain vector of cudaq::measure_results,closed,2024-05-29T16:53:45Z,API-/Usage-/Logic-Bug (High-Level),Framework-Integration,B ,B2,,"G�ltiger C++ Code (xor_result mit measure_result-Vektor), aber MLIR-Inlining-Pass sagt f�lschlicherweise ""Rekursion"" vor.",Problem liegt im aggressive-early-inlining-Pass + Typ-IR-Mapping zwischen C++ und MLIR.,Ein Call-Graph-Analyzer k�nnte echte vs. falsch erkannte Rekursion unterscheiden; aber ben�tigt fortgeschrittene Datenfluss-Analyse.
NVIDIA/cuda-quantum,1703,https://github.com/NVIDIA/cuda-quantum/issues/1703,Segfault during circuit simulation with 2^19 controlled rotation gates,closed,2024-05-22T16:18:59Z,Performance-/Numerik-Bug,Runtime-/Framework-Laufzeit,C,,," Das Problem tritt erst bei sehr vielen cr1/crx-Gates (Schleife mit 2**19 Iterationen) auf und �u�ert sich als Segfault �ber mehrere Targets hinweg - typisch f�r einen Ressourcen-/Performance-Bug (z.B. Stack-/Heap-Exhaustion, zu gro�e IR, o.�.), nicht f�r reine API- oder Config-Themen.","Da das Verhalten target�bergreifend und an MLIR-Enablement gebunden ist, deutet es auf einen Fehler im generischen Runtime-/JIT-/IR-Handling hin (z.B. Scheduling, Speicherverwaltung), nicht in einer speziellen Backend-Library.","Ob eine bestimmte Circuit-Gr��e zum Segfault f�hrt, h�ngt von internen Datenstrukturen, JIT-Strategien und Ressourcenlimits ab; das ist praktisch nicht rein statisch absicherbar, sondern eine Implementierungs-/Runtimefrage."
NVIDIA/cuda-quantum,1682,https://github.com/NVIDIA/cuda-quantum/issues/1682,break within two loops is not handled right.,closed,2024-05-15T12:45:44Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Der User verwendet g�ltige Sprachkonstrukte (while-Schleife, Messung, if res: break); der Compiler produziert aber eine fehlerhafte IR (Arity-Mismatch von cc.unwind_break) - das ist ein Frontend-/Controlflow-Lowering-Bug.","betroffen ist die Logik, die Python-Kernel mit klassischer Kontrolle und Quantum-Messung in eine konsistente IR �bersetzt; Backend und Env sind sekund�r.","Hier ist die Implementierung des Control-Flow-Lowerings kaputt; zus�tzliche statische Checks am Usercode w�rden den Bug nicht vermeiden (der Compiler sollte diesen Pattern gerade unterst�tzen), es braucht robustere Pass-Implementierung/Verification."
NVIDIA/cuda-quantum,1670,https://github.com/NVIDIA/cuda-quantum/issues/1670,[c++] qvector initialization from vector of doubles fails for f32 simulator,closed,2024-05-13T20:07:46Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,A,,,"Semantisch korrekter User-Code (double-Vektor als init state), aber die API/Kernel-Logik akzeptiert keine Typkonvertierung (FP64?FP32) automatisch, obwohl das Codebook vorsieht.","Problem liegt in der Qvector-Constructor-Semantik und deren Fehlerbehandlung, nicht in Backend-Library oder Umgebung.",Statische Typpr�fung k�nnte Precision-Mismatch direkt beim Constructor-Aufruf erkennen; bessere Overloads oder Typconstraints w�rden den Fehler zur Compile-Time abfangen.
NVIDIA/cuda-quantum,1663,https://github.com/NVIDIA/cuda-quantum/issues/1663,Python version on Quantum Cloud does not allow exponentiation operator,closed,2024-05-11T03:30:04Z,Backend-/Framework-Integrations-Bug,"Framework-Integration""",B ,B1,,"Der Code l�uft lokal, aber auf dem Remote-Target scheitert das Legalizing von math.ipowi; das ist ein Problem in der Integration von Python/IR-Lowering mit den Passes/Constraints des Cloud-Backends.","Betroffen ist die Schicht, die Python-Kernel + IR-Pass-Pipeline mit dem Remote-Backend (nvqc) verbindet; mehrere Targets teilen sich dieselbe Frontend-/Pass-Logik."," Man k�nnte sich eine (dom�nenspezifische) statische Kompatibilit�tsanalyse vorstellen, die vorab pr�ft, ob alle verwendeten Ops (** ? ipowi) f�r einen gegebenen Target-/Pass-Pipeline-Satz legalisierbar sind, und andernfalls fr�hzeitig eine klare Compile-Time-Fehlermeldung liefert; das ist fortgeschritten, aber konzeptionell m�glich."
NVIDIA/cuda-quantum,1662,https://github.com/NVIDIA/cuda-quantum/issues/1662,Subtraction of variables gives unhandled BinOp.Sub error within a python kernel,closed,2024-05-10T21:46:43Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Ein syntaktisch v�llig harmloser Ausdruck im Python-Kernel schl�gt fehl, w�hrend eine �quivalente umgeschriebene Form funktioniert - das spricht f�r eine unvollst�ndige/fehlerhafte High-Level-Lowering-/AST-Bridging-Logik."," Der Fehler entsteht beim �bersetzen des Python-AST in die interne IR (Kernel-Front-End), nicht im Backend oder in der Umgebung."," Ob ein bestimmtes AST-Muster im Compiler unterst�tzt wird, ist eine Implementierungsfrage; das l�sst sich nicht durch zus�tzliche Analyse des Usercodes verhindern, sondern nur durch robustere Implementierung/Tests des Frontends."
NVIDIA/cuda-quantum,1620,https://github.com/NVIDIA/cuda-quantum/issues/1620,[Python Kernel] `bool` to `int` type casting issue,closed,2024-05-07T03:41:09Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,B ,B2,,"A measurement result bit = mz(aux) is lowered to IR that sign-extends the i1 value to i64 (sext i1 %7 to i64) and then compares it to 1. Since true becomes -1 under signed extension, the icmp eq i64 %8, 1 condition is never satisfied, so the if bit == 1: branch is logically wrong","The defect is in the kernel codegen. The high-level kernel code is valid, but the generated IR compearision ins obviously incorrect. ",A specialised IR validator or formal check over the codegen pipeline could detect inconsistent patterns like sext i1 followed by comparison with 1 for a logical boolean. and enforce zero-extension or correct comparison 
NVIDIA/cuda-quantum,1618,https://github.com/NVIDIA/cuda-quantum/issues/1618,`MidCircuitMeasurementAnalyzer` doesn't handle all cases of measurement assigned variables ,closed,2024-05-07T01:02:31Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,Bestimmte Formen von Bedingungen werden im Analyse-Helper nicht korrekt behandelt - ein Logik-/Oversight-Bug im High-Level-Analysetool.,"Es betrifft die interne Analyse-/Frontend-Logik (AST/IR-Bridging), nicht Build, Backend oder Runtime.","Die L�cke steckt in der Hilfsfunktion selbst; Usercode-Analyse kann das nicht verhindern, solange der Helper unvollst�ndig implementiert ist."
NVIDIA/cuda-quantum,1571,https://github.com/NVIDIA/cuda-quantum/issues/1571,make check-targets doesn't have all dependencies in the CMakeLists.txt files,open,2024-04-25T23:00:55Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment,B ,B1,,"Die Build-/Install-Logik aktualisiert Runtime-Libraries beim Branch-Wechsel nicht korrekt, was zu Link-/Laufzeitfehlern f�hrt.","Das Problem tritt in der Build-/CI-/Installumgebung auf, bevor irgendetwas simuliert oder kompiliert wird.","Ein pr�ziser modellierter Build-Graph bzw. Tooling, das abh�ngige Targets bei Branch-Wechsel erzwingt neu baut, k�nnte solche Fehler erkennen - das ist aber eine komplexere Build-/Analyseaufgabe."
NVIDIA/cuda-quantum,1566,https://github.com/NVIDIA/cuda-quantum/issues/1566,Cannot pass a list of Pauli words to `observe_async`,closed,2024-04-25T14:24:56Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Synchrones observe akzeptiert eine Liste von Pauli-Strings, observe_async dagegen nicht - das ist eine inkonsistente API-/Contract-Logik.","Der Fehler liegt in den Python-Bindings bzw. der High-Level-API (Overloads/Conversions), nicht in Simulation, Build oder Umgebung.","Das ist eine L�cke in der Implementierung des Async-Overloads; zus�tzliche Analyse des Usercodes verhindert das nicht, es braucht einen Bibliotheksfix."
NVIDIA/cuda-quantum,1539,https://github.com/NVIDIA/cuda-quantum/issues/1539,ChemistryTester bug when nvidia target is available,closed,2024-04-18T12:37:56Z,Backend-/Framework-Integrations-Bug,Framework-Integration,C,,,"Die Python/PySCF-Bindings initialisieren CUDA-Q und setzen den Default-Target auf nvidia, w�hrend der Tester auf QPP FP64 verlinkt ist - Integrations-/Target-Auswahlkonflikt.","Das Problem liegt in der Interaktion zwischen Python-Hilfsbibliothek, Target-Management und C++-Tester (Mischung verschiedener Backends in einer Pipeline).","Globale Target-Umschaltungen und Pr�zisions-Mismatches durch solche Integrationspfade sind Laufzeit-/Konfigurationsdetails, die man nicht realistisch durch statische Analyse des Quantum-Usercodes absichern kann."
NVIDIA/cuda-quantum,1529,https://github.com/NVIDIA/cuda-quantum/issues/1529,Calling kernel functions with list parameters gives incorrect results,closed,2024-04-17T17:05:02Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Der Kernel test_param(i: int, v1: list[int]) -> int sollte jeweils i zur�ckgeben, gibt aber viermal 42 - das ist ein Logik-/Binding-Bug in der Python-Kernel-Call-Implementierung.","Der Fehler steckt in der Art, wie Python-Call-Sites/Argumente in IR/Runtime abgebildet werden, also in der High-Level-Sprach-/Framework-Schicht.","Falsches Capturing/Zuweisen von Argumenten ist ein internes Binding-/Runtime-Problem, das nicht durch zus�tzliche Typ- oder CT-Analysen des Usercodes verhindert werden kann."
NVIDIA/cuda-quantum,1498,https://github.com/NVIDIA/cuda-quantum/issues/1498,Output discrepancy when args of mz are in a list vs when comma separated ,closed,2024-04-11T06:39:51Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Die Mess-API verh�lt sich inkonsistent: als Liste �bergebene Qubits liefern korrekte Bitl�nge, kommagetrennte Argumente nicht - das ist ein klarer API-/Semantik-Bug.","Es geht um die Python-Frontend-/Measurement-API und deren Ergebnisformat, nicht um das Backend.",Die fehlerhafte Argumentbehandlung ist ein Library-Implementierungsproblem; CT-Analysen des Usercodes w�rden daran nichts �ndern.
NVIDIA/cuda-quantum,1469,https://github.com/NVIDIA/cuda-quantum/issues/1469,Cannot run Python range-based for loops through the synthesizer (affects NVQC),closed,2024-04-02T23:58:05Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Standard-Python-Pattern (for i in range(len(parms)): parms[i]) f�hrt zu einem internen IR-/Passfehler, w�hrend die Variante for i in parms funktioniert - das ist ein Frontend-/IR-Generierungsbug.","Das Problem entsteht in der Python-Kernel-MLIR-Erzeugung und dem anschlie�enden Lowering, nicht im Simulator oder Build.","Die fehlerhafte Behandlung von Constant-Arrays und cc.get_const_element in LowerToQIR ist eine interne Pass-Schw�che, die man nicht durch Analyse des Usercodes kompensieren kann."
NVIDIA/cuda-quantum,1464,https://github.com/NVIDIA/cuda-quantum/issues/1464,`cnot` operation is not compiled properly in MLIR mode,closed,2024-04-02T02:46:37Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,"Der Shorthand cnot verletzt seine Semantik, wenn MLIR aktiviert ist, weil er in zwei Einzel-X-Gates statt eine kontrollierte Operation �bersetzt wird - klarer Semantik-/Compiler-Logik-Bug.","Die falsche �bersetzung passiert im Frontend-/MLIR-Lowering des Kernelcodes, bevor ein konkretes Backend ins Spiel kommt.","Ein falsch implementiertes Lowering des Operators ist nur durch Fix/Verification des Compilers behebbar, nicht durch zus�tzliche Checks am Userkernel."
NVIDIA/cuda-quantum,1432,https://github.com/NVIDIA/cuda-quantum/issues/1432,Handle references to constant data in `GenerateDeviceCodeLoader`,closed,2024-03-22T02:29:15Z,API-/Usage-/Logic-Bug (High-Level),Framework-Integration,C,,,Die Design-/Implementierungslogik der Modul-Exzision verl�sst sich nur auf den Callgraph und �bersieht konstant referenzierte Daten - das ist ein konzeptioneller Logikfehler in der Compiler-Pipeline.,"Betroffen ist das Zusammenspiel von Kernel-Modul, Host-Code und Compiler-IR beim Heraustrennen des Kernel-Moduls, also die Integrations-/Compiler-Schicht.","Hier ist die Analyse selbst (Callgraph-Only) unzureichend; zus�tzliche CT-Checks am Usercode �ndern nichts, solange der Exzisions-Algorithmus konstante Daten grunds�tzlich nicht einbezieht."
NVIDIA/cuda-quantum,1431,https://github.com/NVIDIA/cuda-quantum/issues/1431,Endian representation bug in `QppCircuitSimulator::observe`,open,2024-03-22T02:25:40Z,Backend-/Framework-Integrations-Bug,Backend-Library,C,,,Die Umstellung der qpp-Statevector-Endianness wurde in QppCircuitSimulator::observe nicht konsistent mit der Hamiltonian-Matrix-Erzeugung (spin_op::to_matrix) mitgezogen - Integrationsfehler zwischen zwei Backend-Komponenten.,"Der Bug sitzt vollst�ndig in der qpp-Backend-Implementierung (Statevector-Layout vs. Hamiltonian-Matrix), nicht im High-Level-Framework.","Ob Matrix und Statevector dieselbe Endianness verwenden, ist ein internes Backend-Detail, das nicht durch Analyse des Usercodes abgesichert werden kann."
NVIDIA/cuda-quantum,1421,https://github.com/NVIDIA/cuda-quantum/issues/1421,LLVM aarch64 relocation overflow,closed,2024-03-20T03:55:38Z,Performance-/Numerik-Bug,Runtime-/Framework-Runtime,C,,,"Bei speicherintensiven VQEs schl�gt tief im LLVM-JIT eine Relocation-Assertion fehl - typischer Ressourcen-/Numerik-/JIT-Bug, kein simpler API-Fehler.","Der Crash entsteht in der Ausf�hrungs-/JIT-Runtime (RuntimeDyldELF), also in der Laufzeit-Schicht �ber dem Backend.","Solche Gr��en-/Overflow-Probleme in JIT/Relocations sind praktisch nicht durch Typ- oder CT-Analysen des Usercodes vermeidbar, sondern erfordern robustere Runtime-Implementierung."
NVIDIA/cuda-quantum,1400,https://github.com/NVIDIA/cuda-quantum/issues/1400,Circuit drawer retains qubits from previously printed kernel(s),closed,2024-03-14T17:22:45Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,Das Zeichnen desselben Kernels f�hrt durch stale Global-State zu immer l�ngeren Schaltbildern - klarer Logic-/State-Bug in der Draw-API.,"Betrifft die Visualisierungs-/Frontend-Schicht (cudaq.draw), ohne Beteiligung von Simulator oder Environment.","Ein falsch verwalteter globaler Zustand im Draw-Code ist nur durch Korrektur der Implementierung behebbar, nicht durch Analyse des Userkernels."
NVIDIA/cuda-quantum,1396,https://github.com/NVIDIA/cuda-quantum/issues/1396,Batched measurement outputs dont allign to expected results ,closed,2024-03-14T14:50:03Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,Das Verhalten von cudaq.observe mit mehreren Hamiltonian-Terms ist inkonsistent zu der physikalisch erwarteten Semantik f�r unabh�ngige Qubits - Logik-/Semantik-Bug in der Observe-API.,"Das Problem steckt in der Art, wie die High-Level-Observe-Routine Ergebnisse f�r Listen von Termen aggregiert, nicht im Backend oder Build.","Der Fehler liegt in der internen Implementierung der Observe-Logik; zus�tzliche Compile-Time-Checks am Usercode k�nnten das nicht verhindern, es braucht einen Library-Fix."
NVIDIA/cuda-quantum,1374,https://github.com/NVIDIA/cuda-quantum/issues/1374,nvqpp_SampleAsync fails on machines with multiple GPUs,closed,2024-03-12T16:04:15Z,Backend-/Framework-Integrations-Bug ,Runtime-/Framework-Runtime ,C,,,"Der offizielle Async-Sample-CTest crasht mit Double-Free/Heap-Korruption bei Multi-GPU-/MQPU-Einsatz – das ist ein Integrations-/Runtime-Bug (MQPU, Allocator, Async-Scheduling), kein reiner Performance-Bug. ","Der Fehler tritt in der laufenden Test-Binary im Heap-/Runtime-Management auf, nicht im Build oder im High-Level-Frontend. ",Double-Free-/Heap-Korruptionsfehler im internen Runtime-/Allocator-Code sind klassische Implementierungsprobleme; sie lassen sich nicht durch Compile-Time-Analysen des Usercodes vermeiden. 
NVIDIA/cuda-quantum,1367,https://github.com/NVIDIA/cuda-quantum/issues/1367,Synthesizer produces error when mixing certain argument types,closed,2024-03-11T15:54:51Z,Performance-/Numerik-Bug ,Framework-Integration ,C,,,"Ein Syntheseprozess für einen Kernel führt zu std::bad_alloc, offenbar weil durch einen falschen Offset eine viel zu große Struktur interpretiert/alloziert wird – Ressourcen-/Index-/Numerik-Fehler. ","Der Fehler liegt im Zusammenspiel von Argument-Layout und Synthesizer-Logik (Host-Daten → IR/Runtime), also in der Compiler-/Synthesizer-Integrationsschicht. ",Ein falsch berechneter Offset im Synthesizer ist ein Implementierungsbug; das ist nicht sinnvoll durch statische Analyse der Userprogramme zu verhindern. 
NVIDIA/cuda-quantum,1257,https://github.com/NVIDIA/cuda-quantum/issues/1257,Duplicate quake code in `cudaq::get_quake_by_name` if inlining is disabled,closed,2024-02-20T01:48:47Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"Ein Kernel, der einen anderen zweimal aufruft, sollte zu einer sauberen Modulstruktur führen; stattdessen wird die Callee-Funktion doppelt definiert – klarer Codegen-/Logik-Bug. ","Die doppelte Definition entsteht in der MLIR-/Quake-Codegenerierung, also in der Integration von __qpu__-Frontends mit der IR-/Compiler-Infrastruktur. ","Das ist ein interner Fehler des Codegenerators; zusätzliche Analyse des Usercodes ändert nichts, solange der Generator falsch implementiert ist. "
NVIDIA/cuda-quantum,1218,https://github.com/NVIDIA/cuda-quantum/issues/1218,Out of scope kernel ,closed,2024-02-13T09:40:16Z,API-/Usage-/Logic-Bug (High-Level) ,Runtime-/Framework-Runtime ,C,,,"Der User erzeugt einen Kernel in einer Funktion und returned ihn – völlig legitimes Pattern; dass genau diese Schreibweise auf nvidia-mqpu zu einem Segfault führt, deutet auf einen Bug in der Kernel-Lifetime-/Binding-Logik hin. ","Der Crash passiert in der Async-/MQPU-Runtime beim Ausführen, nicht beim Frontend-Lowering.",Objekt-Lifetimes und Speicherverwaltung im Runtime-/Binding-Code sind interne Implementierungsdetails; Compile-Time-Analysen des Usercodes helfen hier nicht.
NVIDIA/cuda-quantum,1215,https://github.com/NVIDIA/cuda-quantum/issues/1215,`cudaq::adjoint` not handling double adjoint.,closed,2024-02-12T22:28:33Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,Eine Kombination von rz<adj> im Kernel und adjoint(foo) führt effektiv zu zwei Adjoint-Rotationen statt zur erwarteten Identität – das ist ein Semantik-/Contract-Bug der adjoint-Logik. ,"Es geht um die High-Level-Gate- und Metaoperation-Logik (Adjoint-Rewriting), nicht um Build, Backend oder Runtime-Env. ","Falsche adjoint-Semantik ist ein Implementierungs-/Designproblem der Library/Compiler-Logik, nicht etwas, das man durch Analyse des Usercodes zur Compile-Time verhindern könnte. "
NVIDIA/cuda-quantum,1175,https://github.com/NVIDIA/cuda-quantum/issues/1175,Tensornet target in Python not registered for async functions ,closed,2024-02-06T15:49:53Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"When the target is set to tensornet, calling cudaq.sample_async(kernel, 10).get() segfaults in DefaultExecutionManager / runSampling, i.e., the async sampling path is not correctly wired up for the tensornet simulator target.",The failure occurs in the integration between the Python async API and the C++  layer that manages different targets. The kernel itself is fine,"This is a backend/runtime integration bug that only manifests when executing with the tensornet target and async sampling. Fits class C, because no static property of the kernel usage that compile-time analysis could flag in advance."
NVIDIA/cuda-quantum,1168,https://github.com/NVIDIA/cuda-quantum/issues/1168,JIT compilation fails when inlining is disabled,closed,2024-02-04T12:30:01Z,API-/Usage-/Logic-Bug (High-Level ,Framework-Integration ,C,,,"Ein legitimer Call von einem __qpu__-Kernel auf einen anderen funktioniert nur, wenn ein bestimmter Inlining-Pass aktiv ist; ohne den entsteht eine inkonsistente IR – Logikfehler in der Compiler-Pipeline. ","Der Bug sitzt in der MLIR-/Compiler-Pass-Pipeline (Call-Resolution, Modulstruktur), also im Zusammenspiel von Frontend und Compiler/Backend. ","Ob ein interner Pass die Ziel-Funktion richtig registriert, ist ein Implementierungsdetail des Compilers; das lässt sich nicht durch zusätzliche Checks am Userkernel absichern. "
NVIDIA/cuda-quantum,1159,https://github.com/NVIDIA/cuda-quantum/issues/1159,cmake dependences aren't quite right,open,2024-02-02T00:08:58Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,B ,B1,,"Executor linkt gegen RestClient, aber die CMake-/Third-Party-Konfiguration baut RestClient nicht – das ist ein klarer Build-/Link-/Packaging-Bug. ","Der Fehler tritt beim Bauen/Linken auf, bevor irgendein Kernel ausgeführt wird. ","Ein sauber modellierter Build-Graph/CMake-Check könnte schon beim Configure/Compile deterministisch feststellen, dass ein benötigtes Target fehlt; das ist eher Build-Analyse als Laufzeitproblem. "
NVIDIA/cuda-quantum,1136,https://github.com/NVIDIA/cuda-quantum/issues/1136,Tensornet backend scratch space allocator is prone to race condition,open,2024-01-25T01:56:05Z,Performance-/Numerik-Bug ,Backend-Library ,C,,,Die Scratch-Size-Heuristik nutzt cudaMemGetInfo und kann in Multi-Tenant- oder Multi-Prozess-Setups falsche freie Speicherwerte sehen – klassischer Ressourcen-/Numerik-/Heuristik-Bug. ,"Die Logik sitzt direkt im tensornet-Backend (Scratch-Allocator), nicht im allgemeinen Framework oder der User-API. ","Race-Conditions bei cudaMemGetInfo zwischen mehreren Prozessen sind ein Laufzeit-/Systemthema; man kann die Heuristik verbessern, aber nicht über Usercode-Analyse vermeiden. "
NVIDIA/cuda-quantum,1117,https://github.com/NVIDIA/cuda-quantum/issues/1117,Intermittent CI llvm-lit test failures for `remote-mqpu` ,closed,2024-01-22T09:41:08Z,Backend-/Framework-Integrations-Bug ,Runtime-/Framework-Runtime ,C,,,"Mehrere parallel laufende remote-mqpu-Tests kollidieren bei der Portwahl – das ist ein Koordinations-/Integrationsproblem der Remote-Runtime, keine reine falsche User-Config. ","Betroffen ist die Netzwerk-/Prozesslaufzeit des Remote-Targets (Socket-Binding, Daemon-Start), also die Runtime-Schicht. ","Port-Kollisionen durch parallel laufende Prozesse sind typische Runtime-/Env-Probleme; sie lassen sich nicht über statische Analyse der Quantum-Programme verhindern, sondern nur durch robustere Port-Management-Logik. "
NVIDIA/cuda-quantum,1108,https://github.com/NVIDIA/cuda-quantum/issues/1108,sample_async race condition,closed,2024-01-18T17:35:49Z,Performance-/Numerik-Bug ,Runtime-/Framework-Runtime ,C,,,"Ein sehr kleiner GHZ-Circuit löst auf nvidia-mqpu einen custatevec out of memory-Fehler aus – das ist eindeutig ein Ressourcen-/Speichermanagementproblem, kein API- oder Config-Fehler des Users. ","Der Fehler entsteht im Zusammenspiel von MQPU-Runtime, sample_async und custatevec zur Laufzeit, also in der Ausführungs-/Runtime-Schicht. ","Wie die MQPU-Runtime intern Speicher allokiert, ist ein Implementierungsdetail; das lässt sich nicht sinnvoll durch Compile-Time-Analysen des Usercodes vermeiden. "
NVIDIA/cuda-quantum,1087,https://github.com/NVIDIA/cuda-quantum/issues/1087,Sporadic test failure in REST platform `get_state_async` test,open,2024-01-12T04:08:39Z,Backend-/Framework-Integrations-Bug ,Runtime-/Framework-Runtime ,C,,,"Das Zusammenspiel von REST-Server, Remote-MQPU-Backend und Tests führt zu Hängern bei get_state_async – klares Integrations-/Orchestrierungsproblem. ","Asynchronität, Scheduling, Timeouts und Prozessinteraktion → eindeutig Runtime-/Framework-Schicht. ","Solche Deadlocks/Hänger sind nur durch bessere Runtime-Implementierung/Monitoring lösbar, nicht durch Compile-Time-Analyse der Quantum-Programme. "
NVIDIA/cuda-quantum,1046,https://github.com/NVIDIA/cuda-quantum/issues/1046,Upgrade pybind11 to the latest version,closed,2023-12-19T17:13:40Z,Backend-/Framework-Integrations-Bug ,Runtime-/Framework-Runtime ,C,,,Bestimmte pybind11-Versionen interagieren nicht korrekt mit dem CUDA-Q-Python-Frontend – Integrations-/ABI-/Bindingproblem. ,"Der Effekt tritt in laufenden Tests im Python-Binding-/Call-Layer auf, nicht beim Bauen der Binaries. ",Kompatibilität von Bindings und Binary-Layout ist ein Runtime-/Implementierungsthema; Usercode-Analyse hilft hier nicht.
NVIDIA/cuda-quantum,1030,https://github.com/NVIDIA/cuda-quantum/issues/1030,Incorrect QIR generated for some conditional measurements (qir_cond_for_loop-6.cpp),closed,2023-12-12T16:47:28Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,Korrekt geschriebener Usercode führt zu logisch falscher QIR/IR (z.B. Mess-/Result-Handling in if-Strukturen) – Compiler-/Semantikbug. ,"Problem sitzt in der CUDA-Q-Compiler-Pipeline (Frontend → MLIR/Quake → QIR), also in der Integrationsschicht. ",Fehlerhafte Transformationen in Compiler-Pässen sind klassische Implementierungsbugs; Compile-Time-Analyse des Usercodes hilft hier nicht. 
NVIDIA/cuda-quantum,1022,https://github.com/NVIDIA/cuda-quantum/issues/1022,`from_state` error with `kernel.qalloc()`,closed,2023-12-11T21:15:47Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,,"Semantisch legitime Nutzung (q = kernel.qalloc() und from_state(q, …)); die API verhält sich aber anders als für qalloc(1) und läuft in einen Fehler → Vertrags-/Semantikbruch der High-Level-API. ","Die Logik steckt in der from_state-/Qubit-API selbst (Single-Qubit vs. qvector), nicht im Simulator-Backend oder Build. ","Die Signatur/Overloads könnten compile-time sicherstellen, dass für kernel.qalloc() nur passende from_state-Aufrufe erlaubt sind bzw. früh eine klare Fehlermeldung erzeugen (z.B. stärker typisierte Qubit-/Container-Typen). "
NVIDIA/cuda-quantum,928,https://github.com/NVIDIA/cuda-quantum/issues/928,qubit-mapping has bug threading wire values,closed,2023-11-14T23:50:07Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"Formal gültiger Usercode führt zu IR, in der lineare „swap“-Wires mehrfach benutzt werden – der Compiler verletzt seine eigenen Linearitätsregeln. ","Fehler entsteht im Zusammenspiel von Quake-/MLIR-Pässen (z.B. Synthese, Qubit-Mapping, Inlining) mit der Linearitätsdisziplin der IR. ",Das ist ein reiner Compiler-/Pass-Implementierungsfehler; er lässt sich nicht durch Typ-/Contract-Checks auf Userseite verhindern. 
NVIDIA/cuda-quantum,920,https://github.com/NVIDIA/cuda-quantum/issues/920,MPI is not enabled in `cudaq` Python wheels,closed,2023-11-14T02:02:49Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,Wheels werden ohne aktivierte MPI-Funktionalität ausgeliefert (im Gegensatz zu Docker/Native-Builds) – klassischer Packaging-/Konfigurationsfehler. ,"Es geht um Build-Flags und Wheel-Erstellung, nicht Runtime-/Compilerlogik. ","Solche Distributionsfehler sind nur durch Build-/Release-Checks adressierbar, nicht durch Typ-/IR-Analysen von Usercode. "
NVIDIA/cuda-quantum,906,https://github.com/NVIDIA/cuda-quantum/issues/906,cudaq.from_state() dosn't work correctly,closed,2023-11-10T22:07:48Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,819,"Ein gültiger Zustandsvektor führt zu einem anderen, inkorrekten internen Zustand – die from_state-API bricht ihre zugesicherte Semantik. ","Fehler liegt in der Mapping-/Repräsentationslogik der High-Level-State-API, nicht im Backend. ",Das ist ein Implementierungsdetail der Framework-State-Repräsentation; Usercode-Analyse kann das nicht verhindern. 
NVIDIA/cuda-quantum,875,https://github.com/NVIDIA/cuda-quantum/issues/875,ConvertExpr buildOp currently not specification adherent. ,closed,2023-11-07T18:49:35Z,API-/Usage-/Logic-Bug (High-Level),High-Level-API / Framework-Logic ,C,,,Das fixup-linkage-Tool setzt falsche Linkage-/Visibility-Eigenschaften für Mach-O/QIR-Artefakte und bricht damit den eigenen Contract gegenüber dem System-Linker. ,"Bug sitzt in der Toolchain-/Compiler-Integrationsschicht (QIR/IR → Objekt → Host-Binary), nicht im Usercode oder Backend. ",Falsche Linkage-Flags in generiertem IR sind reine Tool-/Implementierungsfehler und nicht durch Analyse von Userkernels compile-time vermeidbar. 
NVIDIA/cuda-quantum,873,https://github.com/NVIDIA/cuda-quantum/issues/873,Free function kernels won't work on macOS,open,2023-11-07T11:01:34Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Chemie-/Domain-Code wird falsch an den QPP-Simulator gekoppelt (z.B. falsches Backend/Precision/Statehandling) – Integrationsfehler, kein reiner Build-Flag-Fehler. ","Schicht, in der Chemistry-Code, CUDA-Q-State und Backend-Simulator verdrahtet werden. ",Solche Kopplungsfehler werden über Tests/CI gefunden; sie sind nicht sinnvoll durch Analyse von Userkernels zur Compile-Time vermeidbar. 
NVIDIA/cuda-quantum,867,https://github.com/NVIDIA/cuda-quantum/issues/867,Allow for more complex builder gate signatures in library mode,closed,2023-11-06T21:16:18Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,805,"QPP beschwert sich, weil CUDA-Q die Subsysteme/Indizes so an applyCTRL übergibt, dass Dimensionsverträge verletzt werden – Integrationsproblem, nicht QPP-Bug. ","Bug an der Schnittstelle zwischen CUDA-Q-State-/Registerrepräsentation und QPP-API (Subsystem-Aufteilung, Endianness/Order). ","Ob diese interne Übersetzung stimmt, hängt nur von der Library-Implementierung ab; Usercode-Analyse kann das nicht verhindern. "
NVIDIA/cuda-quantum,866,https://github.com/NVIDIA/cuda-quantum/issues/866,Unable to use IQM QPU machine name with spaces,closed,2023-11-06T12:38:06Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Problem liegt im Zusammenspiel von nvq++-CLI, IQM-Backend und Runtime: die übergebene Machine-String-Option mit Leerzeichen (\""Adonis Variant\"") wird falsch interpretiert, sodass zur Laufzeit eine Architektur-Mismatch-Exception entsteht, obwohl der User die korrekte Architektur angibt. ","Betroffen ist die Integrationsschicht zwischen CUDA-Q-Toolchain/Runtime und dem externen IQM-REST/QPU-Backend (Parsing & Mapping der --iqm-machine-Option), nicht die reine Build-Umgebung oder eine einzelne Backend-Library ",Das ist ein Implementierungsfehler in der Behandlung/Weitergabe von Maschinen-Namen (z.B. Splitten am Leerzeichen oder falscher Vergleich); zusätzliche Compile-Time-Analysen des Usercodes oder stärkere Typisierung der Quantum-Programme würden das nicht verhindern – es braucht einen Fix in der CLI-/Runtime-Implementierung selbst. 
NVIDIA/cuda-quantum,819,https://github.com/NVIDIA/cuda-quantum/issues/819,from_state prepares incorrect state,closed,2023-10-24T03:55:43Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,906,DOUBLE,DOUBLE,DOUBLE
NVIDIA/cuda-quantum,814,https://github.com/NVIDIA/cuda-quantum/issues/814,Ternary operator not working in `__qpu__` kernels,closed,2023-10-23T20:08:17Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,B ,B2,,"The nvq++ compiler is generating IR that always executes the instructions involved in ternary operations. It should generate conditional IR instead. That is - for the a ? b : c expression, it should evaluate a, and then based on the result of a, it should then evaluate b OR c, not both.",The defect lies in the CUDA-Q C++ frontend / Quake IR lowering for ternary (?:) operators inside kernels: the generated IR encodes the wrong control-flow semantics before any backend simulator or environment is involved,A specialised IR verifier or compiler test generator could detect that a supposed conditional expression has both branches evaluated and merged which requires analysis of the generated control flow rather than simple local type/contract checks
NVIDIA/cuda-quantum,810,https://github.com/NVIDIA/cuda-quantum/issues/810,Logical `&&` operator not working in `__qpu__` kernels,closed,2023-10-23T12:35:57Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"Ein Kernel, der mit einem logischen && arbeitet, wird in IR mit falscher Kurzschluss-/Branchlogik übersetzt – der Compiler verletzt die Semantik der High-Level-Sprache. ","Der Fehler sitzt in der IR-Generierung/Optimierung (Frontend → Quake/MLIR → Ziel-IR), also in der Compiler-/Framework-Integrationsschicht. ","Falsch generierte Branch-/Logical-IR ist ein typischer Pass-/Compilerbug; er lässt sich nicht durch Analyse der Userkernels zur Compile-Time vermeiden, sondern nur durch Fix/Verification der Transformationen. "
NVIDIA/cuda-quantum,806,https://github.com/NVIDIA/cuda-quantum/issues/806,[QIR] Lowering ctrl-swap not implemented,closed,2023-10-20T19:29:49Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"Der Lowering-Code für Zwei-Target-Operationen enthält eine harte Fehlermeldung für kontrollierte Varianten, d.h. bestimmte gültige Operationen werden schlicht nicht unterstützt – ein Logik-/Feature-Gap im Compiler. ","Der Bug liegt im LowerToQIR-/Pass-Code (Quake/MLIR → QIR), also in der Compiler-/Framework-Integrationsschicht. ","Dass eine bestimmte Operation im Lowering nicht implementiert ist, ist ein reines Implementierungsthema; zusätzliche Compile-Time-Analysen des Usercodes können das nicht heilen. "
NVIDIA/cuda-quantum,805,https://github.com/NVIDIA/cuda-quantum/issues/805,[QIR] Bug in lowering multi-ctrl to LLVM,closed,2023-10-20T18:58:06Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,867,DOUBLE,DOUBLE,DOUBLE
NVIDIA/cuda-quantum,799,https://github.com/NVIDIA/cuda-quantum/issues/799,Issue with generated thunk for kernel with cc.callable argument,open,2023-10-19T20:17:13Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,Der generierte IR ruft über einen cc.undef-Funktionszeiger statt über einen korrekt gesetzten Pointer – klarer Codegen-/Logik-Bug in der Compilerkette. ,"Der Fehler entsteht in der IR-/Codegen-Integration (Front-End → Quake/MLIR → LLVM/QIR), also in der Compiler-/Framework-Schicht. ",Falsch initialisierte Funktionszeiger im generierten IR sind ein internes Compilerproblem; das kann man nicht durch Usercode-Analyse zur Compile-Time vermeiden. 
NVIDIA/cuda-quantum,776,https://github.com/NVIDIA/cuda-quantum/issues/776,Broadcasting on observe yields incorrect results ,closed,2023-10-16T12:35:16Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Für gebatchte Parameter (3×2 theta_vals) liefert observe eine Liste der falschen Länge (und Typen), d.h. die High-Level-API hält ihren Rückgabe-Contract für batched Inputs nicht ein. ","Der Fehler liegt in der Observe-/Batching-Logik des Python-Frontends, nicht im Backend oder im Build. ","Das ist ein Implementierungsfehler der Ergebnisaggregation; zusätzliche Compile-Time-Analysen des Usercodes ändern daran nichts, es braucht einen Fix im Framework. "
NVIDIA/cuda-quantum,759,https://github.com/NVIDIA/cuda-quantum/issues/759,Hamiltonian list does not work with observe_async,open,2023-10-11T15:44:08Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,A,,,"observe_async unterstützt nur einen einzelnen SpinOperator, bricht aber bei einer Liste ab, obwohl observe mit einer Liste funktioniert – inkonsistente API-/Contract-Logik. ","Betrifft ausschließlich das Python-Frontend bzw. die High-Level-API-Signaturen von observe vs. observe_async, nicht das Backend. ","Mit strengeren Typ-/Overload-Contracts (z.B. unterschiedliche Funktionsnamen oder statisch typisierte Parameter) könnte man zur Compile-Time erzwingen, dass observe_async nur den erlaubten Argumenttyp annimmt oder früh einen klaren Fehler generiert. "
NVIDIA/cuda-quantum,677,https://github.com/NVIDIA/cuda-quantum/issues/677,[Bug] Cross dependence between regression and unit tests,open,2023-09-20T21:04:00Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,"Ein Quake-Regressionstest hängt von IonQ-spezifischer Umgebung/Tests ab, was zu fragilen, Umgebung-abhängigen Testläufen führt – Konfigurations-/Test-Design-Problem. ","Es geht um Test-/Build-Infrastruktur und deren Abhängigkeiten, nicht um Runtime oder Compilerlogik. ","Solche Cross-Dependencies in Tests sind organisatorische/Infra-Probleme; sie lassen sich nicht durch Analyse von Userkernels verhindern, sondern nur durch bessere Teststrukturierung."
NVIDIA/cuda-quantum,640,https://github.com/NVIDIA/cuda-quantum/issues/640,Async execution in Python is broken,closed,2023-09-11T13:28:34Z,Backend-/Framework-Integrations-Bug ,Runtime-/Framework-Runtime ,C ,,,Asynchrone Ausführung verwendet Python-Objekte in C++-Threads ohne korrekte GIL-Handhabung – Integrationsproblem zwischen Python-Runtime und C++-Async-Execution. ,"Der Bug liegt im Laufzeitverhalten (Threads, GIL, Async-Executor), nicht in der Kompilierung oder reinen Backend-Implementierung. ",Race-/Threading-/GIL-Probleme sind Laufzeit-/Implementierungsdetails; sie lassen sich nicht über statische Analyse von Quantum-Usercode zur Compile-Time zuverlässig verhindern. 
NVIDIA/cuda-quantum,637,https://github.com/NVIDIA/cuda-quantum/issues/637,Nightly integration test failures for 4 IonQ tests (empty programs),closed,2023-09-10T20:41:53Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,B ,B2,,Durch Kombination mehrerer Änderungen wird das Programm vollständig wegoptimiert und der IonQ-Backend-Aufruf schlägt auf einem leeren Programm fehl – Problem im Zusammenspiel von Optimizer und Backend-Anforderungen. ,"Der Fehler sitzt in der Compiler-/Framework-Schicht, die IR so optimiert, dass für das IonQ-Backend faktisch kein sinnvoller Code übrig bleibt. ","Ein robuster Optimizer/IR-Validator könnte vor der Submission erkennen, dass das Programm komplett leer ist, und eine Warnung oder einen Fehler ausgeben – das erfordert aber eine zusätzliche, nicht-triviale Analyse. "
NVIDIA/cuda-quantum,630,https://github.com/NVIDIA/cuda-quantum/issues/630,Python formatting of tests not enforced in CI,closed,2023-09-08T19:38:11Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,"Der CI-Job für Python-Formatierung ist so konfiguriert, dass er bei Problemen nicht fehlschlägt und damit Verstöße nicht blockiert – klassischer Fehler in der Build-/Testkonfiguration. ","Betrifft rein die CI-/Build-Schicht (yapf-Check, Exit-Codes), bevor irgendetwas kompiliert oder ausgeführt wird. ","Das ist ein Konfig-/Scriptproblem der CI; Compile-Time-Analyse von Usercode hat hier keinen Hebel, es braucht eine korrekte Pipeline-/Job-Konfiguration. "
NVIDIA/cuda-quantum,609,https://github.com/NVIDIA/cuda-quantum/issues/609,crash in test_runtime_dm,closed,2023-09-06T16:09:04Z,Performance-/Numerik-Bug ,Runtime-/Framework-Runtime ,C,,,"Der Density-Matrix-Runtime-Test liefert falsche/statistisch inkonsistente Ergebnisse bzw. schlägt unerwartet fehl – das ist ein Fehler in der numerischen/algorithmischen Implementierung, nicht im API-Gebrauch. ","Der Fehler tritt beim Ausführen der Runtime-/Simulatorlogik auf (unittests laufen, Binary startet), nicht beim Build oder im High-Level-Frontend. ","Numerik-/Runtime-Bugs in der internen DM-Implementation lassen sich nicht realistisch durch Analyse des Usercodes zur Compile-Time verhindern, sondern nur durch Fixes und Tests im Runtime-Code. "
NVIDIA/cuda-quantum,603,https://github.com/NVIDIA/cuda-quantum/issues/603,Kernel is translated into an invalid QASM,closed,2023-09-05T18:17:38Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Der Translator erzeugt QASM mit Gate-Namen, die mit _ anfangen (QASM 2.0-inkompatibel), und mit Gate-Definitionen, die nach ihrer Verwendung kommen; hier schlägt die Integration zwischen cudaq/Quake-IR und dem OpenQASM-Format fehl. ","Es geht um die Schicht, in der interne Kernel-MLIR in OpenQASM „für externe Consumer“ (QASM-Backends) übersetzt wird – eine klassische Format-/Backend-Integrationsaufgabe, nicht rein interne High-Level-API-Semantik. ","Dass der erzeugte QASM-Text gegen die Spezifikation verstößt, könnte zwar durch zusätzliche QASM-Linting-Schritte erkannt werden, aber das sind wiederum Checks auf dem Generator-Code, nicht auf dem User-Kernel; im Sinne deiner CTClass-Definition (Analyse von User-/Kernel-Code) ist das ein Implementierungsproblem im Translator und damit C. "
NVIDIA/cuda-quantum,583,https://github.com/NVIDIA/cuda-quantum/issues/583,cuda-quantum docker cpu have different result with gpu,closed,2023-08-29T06:19:25Z,Performance-/Numerik-Bug ,Backend-Library ,C,,,"Ohne set_target('nvidia') liefert der VQE-Lauf physikalisch plausible Energien und einen nicht-trivialen Zustandsvektor, mit GPU-Target dagegen immer denselben falschen Wert (≈ -4.10) und einen praktisch Null-State – das ist ein klarer numerischer Korrektheitsfehler im GPU-Pfad, kein reines API- oder Config-Problem. ","Das Problem tritt nur im nvidia-Target auf, also in der GPU-Backend-Implementierung (cuStateVec/cuTensorNet bzw. deren Anbindung); der gleiche High-Level-Code funktioniert mit dem Default-Backend. ","Ob der GPU-Backend-Kern korrekt rechnet, hängt von internem numerischem Code, FP-Pfaden und ggf. Hardwaredetails ab; ein statischer Check der User-Kernels oder API-Verträge kann nicht verhindern, dass ein bestimmte Backend-Pfad immer die gleiche falsche Energie und einen Null-State produziert. "
NVIDIA/cuda-quantum,579,https://github.com/NVIDIA/cuda-quantum/issues/579,Segmentation fault with --emulate option on some programs when saving measurements to variables,closed,2023-08-28T12:47:34Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Das Ändern der Messung von mz(qubits); hin zu auto r0 = mz(qubits[0]); ... ist semantisch harmlos, führt aber plötzlich zu einem Segfault, weil das Framework dann das erwartete __global__-Register nicht mehr befüllt – hier bricht die Messungs-/Result-Semantik der High-Level-API ihren Vertrag. ","Das Report beschreibt, dass sich die LLVM IR kaum ändert, aber zusätzliche registerName-Attribute und das Fehlen des __global__-Registers zu Problemen führen – das ist Logik im Frontend-/Result-Handling, wie Messungen in Kernel-Variablen und globale Result-Register zusammengeführt werden. ","Ein IR-/ABI-Validator könnte zur Compile-Time überprüfen, ob für alle erlaubten Messungs-Patterns (inkl. Speicherung in lokalen Variablen) die Invarianten der Host-ABI erfüllt sind – insbesondere, dass das erwartete __global__-Register korrekt aufgebaut wird; das ist fortgeschrittene, aber prinzipiell statische Analyse. "
NVIDIA/cuda-quantum,577,https://github.com/NVIDIA/cuda-quantum/issues/577,Issue with MLIRGen and NVQ++ Linking,open,2023-08-24T17:41:19Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Das Hinzufügen zusätzlicher (sogar unbenutzter) __qpu__-Kernel-Lambdas ändert das Verhalten des Programms so, dass auf dem RemoteRESTQPU plötzlich keine Counts mehr zurückkommen – das deutet auf eine fehlerhafte Kernel-/Entrypoint-Semantik im User-facing API-/Kernel-Model hin, nicht auf reine Umgebungskonfiguration. ","Der Bug liegt darin, wie das Framework aus den definierten Kernels/Lambdas den „richtigen“ Entry-Point für Remote-Execution bestimmt und Library-Mode vs. direkter QPU-Aufruf verkabelt – das ist Frontend-/Framework-Logik rund um Kernel-Auflösung. ","Ein hinreichend smarter statischer Check über die Kernel-IR/Metadaten könnte erkennen, dass mehrere Kandidaten-Entry-Points definiert sind bzw. dass der als Entry-Point markierte Kernel nicht mit der erwarteten Signatur/Execution-Mode zusammenpasst und die Compilation verweigern, statt in einen „silent failure“-Modus ohne Counts zu laufen "
NVIDIA/cuda-quantum,573,https://github.com/NVIDIA/cuda-quantum/issues/573,ConcatOp Canonicalization,closed,2023-08-22T19:20:03Z,Performance-/Numerik-Bug ,Framework-Integration ,C,,,"Die erzeugte IR ist semantisch korrekt, enthält aber nach Multicontrol-Decomposition und Gate-Set-Mapping überflüssige quake.concat-Operationen, die nur Performance/IR-Qualität betreffen („superfluous and could probably be optimized away“). ","Das Problem entsteht im Zusammenspiel verschiedener Transformations-/Lowering-Pässe, die auf konkrete Backend-Gate-Sets (z.B. Quantinuum) abzielen – also in der Integrationsschicht zwischen Frontend-IR und backendnaher Repräsentation. ","Ob bestimmte No-Op-Pattern tatsächlich wegoptimiert werden, ist eine Frage der Qualität/Existenz von Optimize-Pässen; das ist kein Sicherheits- oder Korrektheitsproblem, das man über zusätzliche Typ-/Contract-Checks auf User-Ebene sinnvoll verhindern würde. "
NVIDIA/cuda-quantum,553,https://github.com/NVIDIA/cuda-quantum/issues/553,Auto-kernel test is failing on ARM,closed,2023-08-13T17:39:23Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Issue beschreibt, dass genau ein bestimmter Test („NVQPP auto-kernel test“) auf aarch64 fehlschlägt und deshalb in PR #548 auf x86_64 beschränkt wurde – es geht nicht um falsche User-API-Nutzung oder Environment-Config, sondern um fehlende/kaputte Unterstützung dieses Pfads auf einer Architektur. ","Der Fehler manifestiert sich beim Ausführen des nvqpp-Auto-Kernel-Workflows (Compiler-Frontend + Backend-Auswahl) auf einer bestimmten Plattform; das ist genau die Integrationsschicht zwischen Framework, Compiler und Zielarchitektur, nicht der reine Build/Installer. ","Architektur-/Plattform-spezifische Laufzeitprobleme (Tests laufen auf x86_64, aber nicht auf aarch64) hängen von Binaries, ABIs und Toolchain-Details ab, die ein statischer Check des User-Codes nicht in den Griff bekommt – realistisch eine C-Klasse "
NVIDIA/cuda-quantum,530,https://github.com/NVIDIA/cuda-quantum/issues/530,Assertion in `vqe_h2.cpp` example with IonQ-emulate target,closed,2023-08-08T13:43:57Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Beispiel vqe_h2.cpp läuft generell, schlägt aber mit IonQ-Target in einer Assertion im Array-Handling fehl („index 4“ bei Größe 4) – das ist ein Fehler im Zusammenspiel des cudaq-Frameworks mit der IonQ-spezifischen Backend-Implementierung, nicht ein genereller API- oder User-Fehler. ","Betroffen ist die Schicht, in der das Framework das IonQ-Backend aufruft und Datenstrukturen (Shots/Results) hin- und herreicht; irgendwo in dieser Integrationslogik wird falsch indiziert.","Der konkrete Off-by-one-Fehler entsteht in der Implementierung des Integrations-/Result-Handling-Codes; ein statischer Check des User-Kernels (oder einfacher Typ-Contracts) kann nicht verlässlich verhindern, dass intern jemand index == size statt < size verwendet. "
NVIDIA/cuda-quantum,521,https://github.com/NVIDIA/cuda-quantum/issues/521,MemToReg on an unmeasured state preparation kernel. ,closed,2023-08-03T13:51:22Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Ein gültiger Kernel ohne Messungen wird durch die Value-Semantik-Pipeline (u.a. factor-quantum-alloc, memtoreg) so transformiert, dass alle Operationen verschwinden und nur noch quake.null_wire übrig bleibt – die API-/Transformationslogik verletzt hier ihre eigene Semantik gegenüber dem Nutzer. ","Der Fehler liegt in der von cudaq bereitgestellten Transformations-/Optimierungspipeline für Kernel-IR (Frontend-/Quake-Ebene), nicht in einem spezifischen Hardware-Backend oder der Umgebung. ",codebook_gpu_quantum_bugs
NVIDIA/cuda-quantum,507,https://github.com/NVIDIA/cuda-quantum/issues/507,nvq++ pass pipeline parser error on hardware,closed,2023-07-27T22:11:44Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Der Fehler tritt nur in den C++-Hardware-Beispielen für IonQ/Quantinuum auf und äußert sich darin, dass die konfigurierte Pass-Pipeline einen nicht registrierten lambda-lifting-Pass enthält, während andere Pfade (Python-Beispiele) funktionieren – klassischer Integrationsfehler im Zusammenspiel von nvq++/cudaq-opt und den Backend-Konfigurationen. ","Betroffen ist die Schicht, in der das Framework die Pass-Pipeline und Backend-Config zusammenschnürt und cudaq-opt aufruft; Build/Environment ist ok, aber die „verkabelte“ Pipeline für diese Targets ist falsch. ","Ob ein bestimmter Passname zur Laufzeit im Pass-Registry tatsächlich verfügbar ist, hängt von Build/Installation und internem Tooling ab; ein Compiler, der nur den User-Kernel analysiert, kann das nicht sinnvoll vorab garantieren – das ist primär ein Tool-/Deployment-Integrationsproblem. "
NVIDIA/cuda-quantum,487,https://github.com/NVIDIA/cuda-quantum/issues/487,Support typedef for integral and floating-point variables/values,closed,2023-07-25T19:53:07Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Das Issue beschreibt, dass __qpu__-Kernels mit „normalen“ Standardtypen als Argumente funktionieren, aber bei typedef/Alias-Typen der Compiler aussteigt und die Typ-Aliaising-Logik unvollständig ist – das ist ein Fehler in der öffentlich sichtbaren Kernel-/Type-Semantik, nicht in der Umgebung oder im Backend. ","Der Bug sitzt im nvq++/Frontend bzw. der Art, wie Kernel-Argumenttypen (inkl. Aliases) analysiert und in Quake/MLIR abgebildet werden – bevor irgendein Backend oder Simulator ins Spiel kommt. ","Mit einer besseren statischen Typ-/Alias-Analyse im Compiler (z.B. normalisierte Darstellung aller erlaubten Aliases, Validator-Pass über die IR) könnte man diese Klasse von Typ-Handling-Bugs prinzipiell zur Compile-Time verhindern; es braucht aber mehr als nur einfache „arg_type == expected“-Checks. "
NVIDIA/cuda-quantum,475,https://github.com/NVIDIA/cuda-quantum/issues/475,Quake measurement ops in value semantics mode,closed,2023-07-24T20:17:47Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,Hier geht es um semantisch falsches Verhalten bei der Kernel-/API-Nutzung – z. B. wie Measurement-/Execution-Logik interpretiert bzw. transformiert wird. ,"Der Fehler liegt in der Nutzer-API und deren Semantik (Kernel/Measurement/Entry-Point-Logik), nicht in Backend oder Deployment. ","Mit hinreichend starker statischer Analyse (z. B. IR-Validator, Entry-Point-/Signature-Checks) wäre solches inkonsistentes API-Verhalten prinzipiell detektierbar. "
NVIDIA/cuda-quantum,454,https://github.com/NVIDIA/cuda-quantum/issues/454,"Runtime failures result in a non-descriptive ""Abort"" error when using Anaconda shell",open,2023-07-21T10:47:24Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Der Fehler tritt beim Versuch auf, einen Job an ein Hardware-Backend (z.B. Remote-QPU) zu submitten, weil Credentials fehlen oder der Submission-Mechanismus fehlerhaft reagiert — klassischer Fehler in der Integration zwischen Framework und Backend, nicht in Nutzer-API oder Build/Evironment. ","Das Problem liegt in der Submission-/Backend-Interaktion, also im Integrationspfad zwischen Nutzer-Code und Remote-Service; nicht in der High-Level-API-Semantik und nicht in reiner Runtime (Performance/Memory). ",Solche Submission/Authentifizierungsfehler lassen sich kaum durch statische Compile-Time-Checks der User-Kernel verhindern — sie hängen von Deployment/Backend-Konfiguration ab. 
NVIDIA/cuda-quantum,428,https://github.com/NVIDIA/cuda-quantum/issues/428,"[Base Profile] Bug with two mz with same registerName = """"",closed,2023-07-17T20:47:18Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,Issue betrifft fehlerhafte Backend-Interaktion bzw. falsche Integration zwischen Framework und Zielsystem – keine Nutzer-Logik oder Umgebungskonfiguration. ,"Der Fehler entsteht in der Schicht, in der das Framework Backend-Komponenten auswählt oder ansteuert: klassische Integrationsschicht. ",Das Problem kann nicht durch statische Analyse des User-Codes erkannt werden — es ist ein Implementierung-/Integrationsfehler. 
NVIDIA/cuda-quantum,426,https://github.com/NVIDIA/cuda-quantum/issues/426,converting to base profile requires updates to __tdg and __sdg functions,closed,2023-07-17T19:04:29Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"The QIR functions for adjoint of T and S (named <prefix>__tdg and <prefix>__sdg) are not correct for QIR base profile. In the base profile those names are spelled <prefix>__t__adj and <prefix>__s__adj, resp. Lowering to base profile needs to be updated.","Might be  a framework or backend integration issue in the Quake QIR lowering for the base profile. The CUDA-Q compiler frontend produces valid high-level kernels, but the QIR backend uses incorrect symbol names for these gates","Whether the emitted QIR obeys the base-profile naming conventions is a backend-spec compliance property that only the QIR generator ""knows"". A generic static checker on user code cannot enforce this, so class C"
NVIDIA/cuda-quantum,417,https://github.com/NVIDIA/cuda-quantum/issues/417,Python should be testable without make install,closed,2023-07-16T17:13:50Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,"Now if you want to test the python bindings from the build directory, you have to run make install in order for the python folder hierarchy to be in the $BUILD/python directory. ",This is a build / deployment pipeline issue in how CMake installs and exposes the Python package layout for testing: the test setup assumes an “installed” package structure rather than using the artifacts already present in the build tree,"Whether the project supports testing Python bindings from the build tree is a property of the build and packaging workflow, not of individual kernels or API usage"
NVIDIA/cuda-quantum,403,https://github.com/NVIDIA/cuda-quantum/issues/403,Submission to IONQ simulator hangs,closed,2023-07-13T17:43:20Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"The executable hangs after submitting a job for execution on the IONQ simulator.  Looking at the dashboard on the ionq website all the jobs are marked as failed due to not having permissions, but hanging the process isn't very informative on the other end. ",The error seems in the integration between CUDA-Q IonQ backend client and the remote IonQ cloud service: job status and error codes from IonQ. no permissions,Whether a remote cloud job fails due to permission issues and how that failure is reported is likely a runtime framework 
NVIDIA/cuda-quantum,399,https://github.com/NVIDIA/cuda-quantum/issues/399,exception thrown in cobyla,open,2023-07-12T17:43:59Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,The generated executable terminates with an uncaught exception being thrown. ,"Seems in the interaction between CUDA-Q (COBYLA) and the IonQ backend path in the framework, not in the user kernel itself: the same example is expected to run, but the integration for this target throws at runtime",An optimiser backend combination throws an exception at runtime depends framework behaviour and numerical edge cases. This is not something a static analysis of the kernel or API usage could reliably predict
NVIDIA/cuda-quantum,381,https://github.com/NVIDIA/cuda-quantum/issues/381,Kernels created by cudaq-quake can't be serialized into OpenQASM,closed,2023-07-09T11:44:04Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C ,,,"When kernels are serialized into MLIR using cudaq-quake, the resulting MLIR code also contains a function that can't be translated into OpenQASM using cudaq-translate. ","Assumption: the quantum kernel itself is fine, but the translator does not know how to deal with additional classical functions in the same module ",Whether the OpenQASM backend supports or skips auxiliary classical functions is a property of that translation pipeline 
NVIDIA/cuda-quantum,380,https://github.com/NVIDIA/cuda-quantum/issues/380,Kernel calls can't be translated into OpenQASM,closed,2023-07-09T09:06:41Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,Quake code in which a kernel is called by another kernel can't be translated to OpenQASM. ,"Problem seems to be in the framework integration between Quake MLIR and the OpenQASM translation backend.  the C++ kernels and Quake IR are valid and runnable, but the OpenQASM codegen cannot handle kernel-to-kernel calls ",Support for translating func call and generating legal  names is a responsibility of the OpenQASM backend 
NVIDIA/cuda-quantum,379,https://github.com/NVIDIA/cuda-quantum/issues/379,`r1` gate isn't correctly translated to OpenQASM,closed,2023-07-09T08:14:30Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"When translating Quake to OpenQASM, r1 gates are translated to cu1 gates instead of u1 gates. ","Assumption: The defect lies in the Quake OpenQASM translation backend, specifically in the gate mapping table that maps CUDA-Q Quake r1 operation to the wrong OpenQASM primitive",Correctness of this Name semantics mapping is a backend specific codegen concern. Ggeneric static analysis of user kernels cannot detect that the translator chose cu1 instead of u1
NVIDIA/cuda-quantum,378,https://github.com/NVIDIA/cuda-quantum/issues/378,Kernels created by `cudaq::kernel_builder` can't be translated to OpenQASM,closed,2023-07-09T07:55:31Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Issue (Fortsetzung von #380) beschreibt, dass der QASM-Generator für Builder-basierte Kernels scheitert, weil z.B. kein cudaq-entrypoint-Attribut gesetzt oder falsch interpretiert wird – das ist ein Problem im Tool-/Backend-Integrationsteil (MLIR → QASM), nicht im User-Kernel selbst. ",The defect lies in the integration between the kernel builder’s to_quake() implementation and the Quake translation to QASM,"Ob der QASM-Translator korrekt mit Builder-Kernels und Entry-Point-Attributen umgeht, hängt von seiner Implementierung ab; eine zusätzliche Analyse des User-Kernels kann nicht sicherstellen, dass die Tool-Kette einen gültigen QASM-Output erzeugt – daher CTClass C. "
NVIDIA/cuda-quantum,349,https://github.com/NVIDIA/cuda-quantum/issues/349,IR produced when compiling for Quantinuum and IonQ backends is not spec compliant,closed,2023-07-05T12:45:03Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,B ,B2,,"Das Issue sagt explizit, dass die Namen der QIR-Funktionen für T- und S-Adjoint (__tdg, __sdg) nicht dem QIR Base Profile entsprechen und zu __t__adj/__s__adj geändert werden müssen – das ist eine Fehlintegration zwischen CUDA-Qs QIR-Emitter und der formalen QIR-Spezifikation. ","Wir befinden uns genau in der Schicht, in der CUDA-Q seine interne Repräsentation in QIR Base Profile gießt, damit andere Tools das interpretieren können – also eine Format-/Backend-Integrationsaufgabe. ","QIR Base Profile ist formal spezifiziert; ein QIR-Validator (z.B. im Stil von QAT) könnte zur Compile-Time prüfen, ob alle Funktionsnamen und Signaturen kompatibel sind und die Base-Profile-Regeln einhalten – das ist eine fortgeschrittene IR-Analyse und damit CTClass B. "
NVIDIA/cuda-quantum,345,https://github.com/NVIDIA/cuda-quantum/issues/345,Error when trying to simulate `qspan`,closed,2023-07-03T19:57:10Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Issue zeigt, dass das Zusammenspiel mit einem bestimmten Simulator/Backend (z.B. qpp) zu Crash/Fehlverhalten führt – nicht, weil der Algorithmus numerisch instabil ist, sondern weil die Integration (Kontroll-/Target-Dimensionen, Mapping etc.) nicht korrekt implementiert ist. ","Ursache ist die Art, wie das Framework den qpp-Backend-Aufruf vorbereitet (z.B. Falsches Layout, falsche Parameter, falsche Kontroll-/Target-Belegung), also klare Integrationsschicht zwischen High-Level-Kernel und Backend. ","Ein statischer Check auf User-Kernel-Level kann nicht sicherstellen, dass der interne qpp-Aufruf keine Off-by-one-/Dimensionierungsfehler in der Implementierung hat; das ist Implementierungsarbeit im Integrationscode → C. "
NVIDIA/cuda-quantum,344,https://github.com/NVIDIA/cuda-quantum/issues/344,Compiler crash when compiling a kernel with `std::uint8_t` as argument,closed,2023-07-03T19:52:03Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Nutzer verwenden bestimmte legalen C++-Typen oder Signaturen für __qpu__-Kernels, woraufhin der Compiler/Bridge crasht oder falsche IR erzeugt – das ist ein Logikfehler der High-Level-Schnittstelle (Type-/Signature-Handling), nicht ein Backend- oder Buildproblem. ","Wie Kernel-Argumenttypen analysiert und in IR übersetzt werden, ist klar Aufgabe des High-Level-Frontends; der Bug sitzt dort (z.B. in Typableitung, Funktionssignatur-Handling), nicht im darunterliegenden Backend oder einer externen Library. ","Mit einem robusteren Typ-/Signature-Validator für Kernel-Definitionen (der sicherstellt, dass nur unterstützte Typen in zulässigen Kombinationen vorkommen und alle Branches des Type-Dispatch abgedeckt sind) könnte man solche Fehler prinzipiell zur Compile-Time erkennen/verhindern; das braucht aber erweiterte Compiler-Analysen und klare Typregeln → B. "
NVIDIA/cuda-quantum,343,https://github.com/NVIDIA/cuda-quantum/issues/343,Unable to unroll a counted loop,closed,2023-07-03T19:41:01Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Das Issue beschreibt ein fehlerhaftes Verhalten/Crash im Zusammenspiel mit einem bestimmten Backend/Target (kein reiner „langsamer“ oder numerisch ungenauer Pfad), sondern dass etwas im Framework↔Backend-Weg kaputtgeht – typisch für 1.3. ","Die Ursache liegt in der Verkabelung von CUDA-Q-Mechanismen mit einem konkreten Backend (z.B. IonQ/Quantinuum/QIR-Pfade), nicht im High-Level-API-Design oder Build-System selbst. ","Diese Art Integrations-/Crash-Fehler entsteht aus den internen Details der Aufrufkette und der Backend-Implementierung; ein Compile-Time-Check auf Basis von User-Kernel-IR kann nicht sicherstellen, dass der richtige Backend-Call mit korrekten Parametern implementiert ist. "
NVIDIA/cuda-quantum,341,https://github.com/NVIDIA/cuda-quantum/issues/341,Linker error when trying to build kernel with `std::acos`,closed,2023-07-03T17:13:10Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Hier geht es darum, dass bestimmte Standard-Math-Funktionen (acos etc.) im resultierenden QIR/Backend-Profil nicht korrekt an die Zielumgebung angebunden werden (z.B. falscher Name oder fehlendes Mapping) – das ist ein Fehler im Zusammenspiel von Compiler/QIR und Runtime-/Math-Library. ","Betroffen ist die Schicht, die QIR-/IR-Funktionen auf konkrete Runtime-Funktionen der Zielplattform mappt; es ist keine Build-/Install-Frage und auch nicht reine High-Level-API-Semantik, sondern Integration von Backend-Profil und tatsächlicher Laufzeitumgebung. ","Ob ein Linker-/Runtime-Symbol korrekt verknüpft ist, hängt von Toolchain, Symbolnamen und Runtime-Layout ab – ein statischer Check des User-Kernels kann das in der Praxis nicht zuverlässig verhindern; damit ist das CTClass C. "
NVIDIA/cuda-quantum,339,https://github.com/NVIDIA/cuda-quantum/issues/339,Failure to create `qreg` using kernel argument as size,closed,2023-07-03T16:16:40Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,A ,,,We seem to be getting a failure when trying to allocate a qreg that has a size defined by an argument: ,"This is a defect in the CUDA-Q library that lowers kernels and implements qreg construction, not in the users host code or environment, hence it sits in the Backend-Library layer.","A straightforward compiletime contract or type check on the qreg constructor could have caught this mismatch early, so we classify as A"
NVIDIA/cuda-quantum,338,https://github.com/NVIDIA/cuda-quantum/issues/338,Handle func::ConstantOp for adjoint / control in the ASTBridge,closed,2023-07-03T16:05:47Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Das Issue zeigt, dass das Verwenden einer freien __qpu__-Funktion als Funktionszeiger in cudaq::adjoint() aktuell zu einem Compilerfehler führt und man in ConvertExpr.cpp spezielle Typ-Checks nachrüsten muss – der Nutzer macht semantisch legitime API-Nutzung, aber die High-Level-Logik unterstützt diesen Fall nicht. ","Die vorgeschlagene Lösung betrifft direkt den Frontend-/Type-Checking-Code (ConvertExpr.cpp) im CUDA-Q-Compiler: es fehlt ein Branch für FunctionType, also High-Level-API-/Compiler-Frontend-Logik, nicht Backend. ","Dass genau dieser Funktions-Typfall in der Implementation des Frontends nicht behandelt ist, ist ein interner Compiler-Bug; ein separater Compile-Time-Analyseschritt, der den User-Code inspiziert, kann das nicht „präventiv“ verhindern – die Korrektur ist im Compiler selbst, nicht durch zusätzliche Constraints auf den Kernel. "
NVIDIA/cuda-quantum,337,https://github.com/NVIDIA/cuda-quantum/issues/337,Disappearing instructions.,closed,2023-07-03T15:43:02Z,API-/Usage-/Logic-Bug (High-Level) ,Framework-Integration ,C,,,"Das Verhalten ist ein semantischer Fehler im sichtbaren Verhalten der CUDA-Q-API bzw. im Zusammenspiel der vom Nutzer aufgerufenen High-Level-Funktionalität, nicht primär ein reiner Performance-/Numerikfehler – das Issue beschreibt „falsche“ bzw. inkonsistente Logik. ","Die Ursache liegt im Zusammenspiel von High-Level-Frontend und darunterliegenden Komponenten/Targets (z.B. bestimmte Targets oder Execution-Pfade reagieren anders als erwartet); also Integrationsebene, nicht nur frontendinterne Syntax/Parsing. ","Die konkrete Fehlersituation ergibt sich aus der Implementierung des Framework-Integrationspfads; es gibt keinen einfachen oder auch nur fortgeschrittenen Check auf dem User-Kernel, der diese Art Integrations-Logikfehler vorab deterministisch erkennen würde. "
NVIDIA/cuda-quantum,327,https://github.com/NVIDIA/cuda-quantum/issues/327,Makefiles are missing dependencies,closed,2023-06-29T22:24:05Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,"Das Issue beschreibt, dass man zum Testen der Python-Bindings aus dem Build-Verzeichnis erst make install laufen lassen muss, weil die Python-Hierarchie sonst nicht an der erwarteten Stelle liegt – das ist klassischer Install-/Packaging-/CMake-Logik-Bug. ","Betroffen ist die Art, wie das Projekt gebaut und installiert wird (Build-Dir vs. Install-Dir, Python-Pfadstruktur), nicht die Laufzeit-Interaktion mit einem Quantum-Backend oder die API-Semantik. ",Solche Build-/Installationspfad-Probleme sind durch Analyse von __qpu__-Kernels oder API-Aufrufen nicht zu verhindern; sie hängen von CMake-/Packaging-Entscheidungen und Dateisystemlayout ab → klar CTClass C. 
NVIDIA/cuda-quantum,325,https://github.com/NVIDIA/cuda-quantum/issues/325,Calling a kernel via an instance creates an incorrect allocation,closed,2023-06-29T18:02:09Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Das Beispiel zeigt zwei __qpu__-Kernels (S1, S2), bei denen der Bridge/Frontend aus formal korrektem C++/CUDA-Q-Code eine fehlerhafte cc.alloca-IR erzeugt – das ist ein Logikfehler im High-Level-Kernel-/IR-Generierungsverhalten, nicht ein Build- oder Backend-Implementierungsproblem. ","Der Fehler sitzt direkt in der Übersetzung von C++-Kernelstrukturen (Funktionsobjekte, Aufruf von S2 in S1) in Quake/MLIR; hier arbeitet die High-Level-Frontend-Logik falsch, bevor irgendein konkretes Backend ins Spiel kommt. ","Ob der Bridge eine „malformed cc.alloca“ erzeugt, hängt von interner Implementierungslogik im Compiler ab; das lässt sich nicht durch zusätzliche Typ- oder Contract-Checks auf User-Kernel-Seite zuverlässig verhindern – man braucht robuste Implementierungstests, nicht CT-Analysen des Nutzer-Codes. "
NVIDIA/cuda-quantum,296,https://github.com/NVIDIA/cuda-quantum/issues/296,Failing to compile `if` statements to quantinuum target,closed,2023-06-26T13:43:09Z,API-/Usage-/Logic-Bug (High-Level) ,Backend-Library ,C,,,"When targeting quantinuum, the compiler seems to fail lowering if statements. ",The crash happens during backend lowering qnd JIT compilation for the Quantinuum target,This is an internal compiler and JIT bug for a specific backend. A static analysis of user kernels cannot predict or prevent an LLVM assertion 
NVIDIA/cuda-quantum,291,https://github.com/NVIDIA/cuda-quantum/issues/291,[pass] Multicontrol decomposition erases non-multi control ops,closed,2023-06-26T09:09:14Z,Performance-/Numerik-Bug,Framework-Integration ,C,,,Ein Decomposition-/Optimierungspass für „multi control“ löscht fälschlich auch andere Operationen und verändert damit die Programmsemantik – ein Fehler in der Transformations-/Optimierungspass-Logik. ,"Betroffen ist das IR-Transformations-Backend (MLIR-/Compiler-Pässe) im CUDA-Q-Stack, also wieder die Compiler-/Framework-Integrationsschicht, nicht die High-Level-API oder das Deployment. ","Der Bug steckt in der Implementierung des Passes selbst (falsche Rewrite-Regeln); statische Analyse des Usercodes kann nicht vorhersagen, dass der Compiler intern falsch transformiert und Ops entfernt → C. "
NVIDIA/cuda-quantum,281,https://github.com/NVIDIA/cuda-quantum/issues/281,Canonicalization of extract_ref doesn't fold constants with index type,closed,2023-06-22T19:45:14Z,Performance-/Numerik-Bug,Framework-Integration ,C,,,"Hier fehlt bzw. funktioniert ein Canonicalization-/Optimierungspass im IR-Pipeline-Kontext, so dass unnötig „schlechter“/nicht optimierter Code stehen bleibt – das ist ein Optimierungs-/Performanceproblem. ","Die Ursache liegt in der Zusammenstellung/Integration der Compiler-Pipeline (welche Pässe wann laufen), also in der IR-/Framework-Integrationsschicht, nicht im Buildsystem. ","Ob bestimmte Canonicalization-/Optimierungspässe in der Pipeline enthalten sind und korrekt funktionieren, ist rein Implementierungsdetail des Compilers; der Userkernel ist davon unabhängig und bietet keinen Hebel für statische Vermeidung → C. "
NVIDIA/cuda-quantum,276,https://github.com/NVIDIA/cuda-quantum/issues/276,Platform config files cannot handle passes with options,closed,2023-06-22T09:14:55Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Die Pipeline-Config für Lowering-/Optimierungspässe wird durch eine zu naive String-Splitting-Logik („split on '='“) zerstört, weil Pass-Optionen selbst = enthalten – klassischer Integrations-/Config-Parsing-Bug in der Runtime-Hilfsschicht. ","Es geht um die Integration der Text-Konfiguration (PLATFORM_LOWERING_CONFIG) mit der Pass-Pipeline im Runtime-/Backend-Wrapper, also eindeutig Framework-Integration und nicht reines Build-Environment. ","Der Fehler sitzt im Parser für Konfigurationsstrings; weder Typen noch statische Analyse des Userkernels können verhindern, dass jemand eine solche naive String-Operation implementiert → C. "
NVIDIA/cuda-quantum,258,https://github.com/NVIDIA/cuda-quantum/issues/258,Driver wrongly reporting argument as ignored,closed,2023-06-14T08:59:36Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Der nvq++-Driver meldet --quantinuum-url fälschlich als „ignored“, obwohl das Argument von der Target-Konfigurationsskriptseite tatsächlich verwendet wird – das ist fehlerhafte User-facing-Logik/Fehlermeldung. ","Betroffen ist die CLI-/Driver-Schicht (nvq++) als Teil der High-Level-API, nicht das Backend selbst oder die Build-Umgebung. ","b ein bestimmtes CLI-Argument intern wirklich benutzt wird oder die Warnung korrekt formuliert ist, ist eine reine Implementierungsfrage im Tool; das hat keinen Bezug zum Userkernel und ist nicht durch Typ-/IR-Analyse abfangbar → C. "
NVIDIA/cuda-quantum,252,https://github.com/NVIDIA/cuda-quantum/issues/252,A job should not be posted if we failed JIT compilation ,closed,2023-06-13T15:38:36Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,Hier wird trotz JIT-Fehler („could not trace offset value“) trotzdem ein Job an den Quantinuum-Backend-Mock geschickt – ein klares Fehlerhandling-/Integrationsproblem zwischen JIT und Job-Submission. ,Es geht um die Übergabe von „JIT erfolgreich/fehlgeschlagen“ an den Remote-Backend-Client und dessen Job-Submission – also die Integration zwischen Compiler-Runtime und Remote-Service. ,"Ob der JIT-Fehler korrekt abgefangen und ein Job unterdrückt wird, hängt allein von der Implementierung der Runtime-/Submission-Logik ab; der Userkernel ist syntaktisch/semantisch korrekt, daher keine sinnvolle Compile-Time-Prävention → C. "
NVIDIA/cuda-quantum,251,https://github.com/NVIDIA/cuda-quantum/issues/251,Lowering single qubit allocations to base profile,closed,2023-06-13T15:29:39Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Die Base-Profile-Lowering-Pipeline bricht bei einem Kernel mit einzelner Qubit-Allocation mit „could not trace offset value“ ab – das ist ein Fehler im Zusammenspiel von CUDA-Q-Lowering und Base-Profile/QIR, nicht im Usercode. ",": Betroffen ist die Integration von High-Level-IR (MLIR/Quake) mit der Base-Profile-/Quantinuum-Lowering-Schicht, also die Compiler-/Framework-Integrationslage. ","Ob der Lowering-Code mit bestimmten IR-Patterns (Single-Qubit-Alloc, bestimmte Layouts) korrekt umgehen kann, ist eine Frage der Pass-Implementierung; das lässt sich nicht durch zusätzliche Typ- oder Contract-Checks auf dem Userkernel sicher erkennen → C. "
NVIDIA/cuda-quantum,250,https://github.com/NVIDIA/cuda-quantum/issues/250,Free function kernel compilation in MLIR compilation mode,closed,2023-06-13T15:24:32Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Der „multiple definition of super“-Fehler entsteht, weil die Toolchain denselben Kernel-Symbolnamen aus verschiedenen Artefakten falsch verknüpft – klassischer Toolchain-/Integration-Bug, kein reiner Config-Fail. ","Es geht um die Integration zwischen nvq++-Frontend, erzeugtem QIR/Objektcode und dem Linker für das Quantinuum-Target – also um die Framework-/Toolchain-Integrationsschicht. ",nicht sinnvoll compile-time vermeidbar 
NVIDIA/cuda-quantum,179,https://github.com/NVIDIA/cuda-quantum/issues/179,Fix bugs in lowering to base profile [was: Counted loops from the ASTBridge],closed,2023-05-19T14:24:45Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,B ,B2,,"Der Compiler erkennt template-basierte Loops mit konstanter Schranke (N - 1) nicht als „counted loops“ – das ist eine Lücke in der High-Level-Compilerlogik/Loop-Erkennung, kein Environment- oder Backendproblem. ","Betroffen ist das CUDA-Q-Frontend (AST-Bridge / frühe MLIR-Pässe), die C++-Template-Semantik korrekt in Quantum-Loops abbilden müssten – also die High-Level-API-/Compilerlogik-Schicht. ","Mit geeigneter statischer Analyse (Constant Folding für Template-Parameter, Loop-/Control-Flow-Analyse) kann man solche Loops zur Compile-Time als „counted“ erkennen; das ist nicht trivial (kein simpler Typcheck), aber theoretisch machbar → B. "
NVIDIA/cuda-quantum,177,https://github.com/NVIDIA/cuda-quantum/issues/177,CI error after merge ,closed,2023-05-18T11:30:53Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,C,,,"Das Problem tritt beim Bauen der Docker-/Dev-Umgebung auf (fehlende/inkorrekte base_image-/Build-Args, Cache-Verhalten), also klar ein Build-/Packaging-Fehler. ","Es geht um Docker-Builds und Image-Konfiguration, also um Deployment-/Umgebungsfragen und nicht um die laufende CUDA-Q- oder Backend-Logik. ","Ob ein Docker-Build-Arg gesetzt ist und welche Base-Images verfügbar sind, lässt sich nicht über Analyse des CUDA-Q-Usercodes prüfen; das ist reines Build-/CI-Setup → C. "
NVIDIA/cuda-quantum,174,https://github.com/NVIDIA/cuda-quantum/issues/174,Bug in QuakeObserveAnsatz Pass for GCC 11.3,closed,2023-05-17T19:33:52Z,Backend-/Framework-Integrations-Bug ,Framework-Integration ,C,,,"Der Crash entsteht im observeAnsatz-/Compiler-Pass selbst (z.B. null Context beim Reifyen), also in der internen Integration der Analyse-/Transformations-Pipeline, nicht durch falsche Nutzung der API durch den User. ","Betroffen ist das Zusammenspiel von CUDA-Q-Frontend, MLIR-Pässen und dem internen Observe-/Ansatz-Handling – also die Compiler-/Framework-Integrationsschicht, nicht das Backend oder die Build-Umgebung. ","Das Problem ist ein Implementierungs-/Null-Check-Fehler im Pass selbst; statische Analyse des User-Kernels hilft hier nicht weiter, deshalb kein sinnvoller Compile-Time-Schutz über Typen/Contracts → C. "
NVIDIA/cuda-quantum,149,https://github.com/NVIDIA/cuda-quantum/issues/149,Fix Compiler Warning in QubitQIRExecutionManager,closed,2023-05-10T12:38:35Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,A,,,"Der gemeldete Defekt äußert sich als Compiler-Warnung (-Woverloaded-virtual) beim Bauen – der Build-Prozess ist „unsauber“, obwohl das Programm läuft, also ein Build-/Code-Qualitätsproblem ","Der Effekt tritt beim Übersetzen der Runtime-Klassen (BasicExecutionManager vs. QIRExecutionManager) auf und gehört damit zum Build-/Toolchain-Layer, nicht zur eigentlichen Laufzeit- oder API-Schicht. ",Der Compiler erkennt das Problem bereits heute (Warnung mit exakter Quellstelle); mit passenden Warning-Policies oder CI-Regeln ließe sich dieser Fehler strikt compile-time verhindern. 
NVIDIA/cuda-quantum,83,https://github.com/NVIDIA/cuda-quantum/issues/83,Build issues with cuQuantum SDK v23.03 installed via Ubuntu apt-get,closed,2023-04-13T03:20:17Z,Build-/Install-/Packaging-Bug,Build/Deploy/Environment ,B ,B1,,"When installing cuquantum via apt-get (e.g., sudo apt-get -y install cuquantum) as described here, with the latest cuQuantum SDK v23.03, the install location is different from the previous version: ",This is a build / deployment integration problem between CUDA-Q CMake scripts and the cuQuantum SDK packaging ,"A configure time CMake check using find_library over standard system lib directories (as suggested in the issue) could robustly detect the new cuQuantum layout and fail fast with a clear hint, making this a classic environment "
NVIDIA/cuda-quantum,69,https://github.com/NVIDIA/cuda-quantum/issues/69,Bug with getting expected value from observe_result with no shots provided,closed,2023-04-05T14:30:21Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Das Zusammenspiel cudaq.observe(...) + result.expectation_z(cudaq.spin.z(1)) reagiert nur korrekt, wenn explizit shots_count gesetzt ist; die Default-Semantik ist inkonsistent mit den Nutzererwartungen und der API-Doku – High-Level-Logic-Bug. ","Der Fehler liegt in der Ergebnisverarbeitung und Statistik-Logik der Python-API, nicht in einem bestimmten Backend oder der Build-Umgebung. ","Ob Default-Parameter und Auswertungsmethoden die „richtige“ physikalische Größe liefern, hängt von der konkreten Implementierung der Statistik- und Samplinglogik ab – das kann man nicht sinnvoll durch statische Analyse des User-Kernels verhindern. "
NVIDIA/cuda-quantum,64,https://github.com/NVIDIA/cuda-quantum/issues/64,Seg fault after printing the circuit in python ,closed,2023-04-04T20:47:21Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Ein semantisch legaler Pattern (x-Gate, print(circuit), danach noch ein Gate) führt zu einem Segfault – das ist ein Fehler in der internen Repräsentation/Mutationslogik der High-Level-Circuit-API, nicht bloß „Langsamkeit“ oder Numerik. ","Betroffen ist die Python-Kernel-Repräsentation von CUDA-Q und ihre print-Implementation; das Problem entsteht, bevor irgendein Simulator/Backend angesprochen wird. ","Dass print interne Pointer/State so durcheinanderbringt, dass der nächste Gate-Aufruf crasht, ist ein Implementierungsfehler in der API; zusätzliche statische Checks am Usercode können diesen Laufzeit-State-Korruptionsbug nicht verhindern. "
NVIDIA/cuda-quantum,49,https://github.com/NVIDIA/cuda-quantum/issues/49,ExecutionManager Needs Updates for Handling Qudits,closed,2023-04-03T14:24:12Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Das Issue fordert, ExecutionManager und zugehörige API so zu refactoren, dass sie Qudits (mehr als 2 Levels) korrekt unterstützen; aktuell ist das Interface qubit-spezifisch designt – ein reines API-/Design-/Logikthema. ","Es geht um die abstrakte ExecutionManager-API und deren Signaturen (QuditInfo, returnQudit etc.), also genau die High-Level-Framework-/Sprachspezifikationsschicht. ","Ob das API-Design quditfähig ist, hängt von der gewählten Schnittstelle ab; eine Analyse des Usercodes kann nicht „erzwingen“, dass die Bibliothek ein anderes, allgemeineren Interface implementiert – das ist kein CT-Vermeidbarkeitsfall im Sinne deines Entscheidungsbaums. "
NVIDIA/cuda-quantum,28,https://github.com/NVIDIA/cuda-quantum/issues/28,Incorrect list of QPUs returned from query of runtime,closed,2023-03-24T12:54:49Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"cudaq.list_qpus() listet 'custatevec', obwohl der korrekte Name laut restlichem Stack cuquantum ist – das ist ein falscher Eintrag in einer User-facing API. ","Die Funktion ist Teil des High-Level-Frontends und ihrer statischen Backend-Registry; der Fehler liegt in dieser API-Liste, nicht im unteren Backend-Layer ","Auch wenn man intern Tests/Checks bauen kann, ist das im Sinne deines CT-Konzepts kein Problem, das sich durch zusätzliche Analyse des User-Kernels abfangen lässt – es ist ein harter Implementierungs-/Konstantenfehler im Framework. "
NVIDIA/cuda-quantum,27,https://github.com/NVIDIA/cuda-quantum/issues/27,RuntimeError for MGMN backend,closed,2023-03-24T10:38:09Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Die Doku verweist auf einen Backend-Namen cuquantum_mgmn, den cudaq.set_qpu('cuquantum_mgmn') dann als „Invalid qpu name“ ablehnt – das ist ein inkonsistentes High-Level-API-/Dokumentationsverhalten, kein Backend- oder Buildproblem. ",Betroffen ist die Ebene der QPU-Selektions-API und ihrer Registry von gültigen Backend-Strings; das spielt sich komplett im High-Level-Framework ab. ,"Der Fehler ist ein interner Daten-/Dokubug im Framework; eine Analyse des Usercodes (z.B. String-Literals) reicht nicht aus, um zur Compile-Time sicherzustellen, dass Doku, Registry und Implementierung konsistent gehalten sind – das ist letztlich Wartungs-/Implementierungsdisziplin, nicht CT-Analyse. "
NVIDIA/cuda-quantum,3,https://github.com/NVIDIA/cuda-quantum/issues/3,Fix bug with mid-circuit measurement to a named register,closed,2023-03-20T19:15:47Z,API-/Usage-/Logic-Bug (High-Level) ,High-Level-API / Framework-Logic ,C,,,"Der User ruft kernel.mz(qreg, register_name=""test_measurement"") auf und erwartet, dass measure_counts.register_names() diesen Namen enthält; das Feature ist aber im CircuitSimulator (noch) nicht umgesetzt – der API-Vertrag wird gebrochen. ","Das Problem liegt im Verhalten des High-Level-Simulators und der Sampling-Result-API (Register-Name-Handling), nicht in Backend-Libs oder Build-/Env-Fragen. ","Ob ein Keyword-Argument wie register_name wirklich unterstützt und korrekt ins Result-Objekt übertragen wird, ist eine Frage der internen Implementierung und Tests; das kann nicht durch zusätzliche Compile-Time-Analyse des Usercodes garantiert werden. "
