| Issue                                                                                   | Alternative Labels (before adjudication) | Why it is borderline                                                                                                                                                                                                                                                                             | Final decision + rule (conservative)                                                                                                                                                |
| --------------------------------------------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **CUDA-Q #920 — “MPI is not enabled in cudaq Python wheels”**                           | **B1 ↔ C**                               | Packaging advertises/ships an API surface, but the functionality is absent (stubs/feature missing in the wheel). A pure metadata/support-matrix check (B1) is brittle if the artifact exposes the API while not providing the implementation.                                                    | **C** — treat “API present but non-functional” as runtime/artefact-level failure; avoid optimistic “install-time checkable” claims.                                                 |
| **CUDA-Q #2628 — “cudaErrorIllegalAddress at mqpu”**                                    | **B2 ↔ C**                               | One could argue for stronger preflight/guards (B2) around IDs, resource selection, and safety checks. However, illegal-address faults in multi-GPU/asynchronous execution are often timing/context dependent and manifest only at runtime.                                                       | **C** — if the failure is driven by asynchronous runtime/hardware behavior rather than invalid static inputs, classify as runtime-only (conservative).                              |
| **CUDA-Q #1464 — “CNOT degradation / control semantics lost in MLIR lowering”**         | **B ↔ C** (not “simple B2”)              | A “B” argument would require semantic verification of compiler transformations (e.g., IR-level equivalence/invariants across lowering). In practice, user code is valid and the miscompile is silent; without heavyweight semantic checking, it is not realistically prevented before execution. | **C** — when prevention would require semantic equivalence checking in the compiler pipeline, adjudicate as C to avoid overstating compile-time checkability.                       |
| **CUDA-Q #2279 — “Mid-circuit measurements: missing state collapse / wrong semantics”** | **A ↔ C**                                | The program is syntactically valid; the issue is a backend/simulator semantic mismatch (wrong-results). Static typing or surface-level contracts do not capture the physical/semantic modeling choice inside the backend.                                                                        | **C** — backend semantic/wrong-results issues are treated as runtime/back-end dependent (conservative).                                                                             |
| **CUDA-Q #875 — “State preparation broadcasting / ASTBridge spec adherence”**           | **B2 ↔ C**                               | A B2 argument would be “add API/parameter checks for shape/qubit count.” But the fix indicates the bridge/lowering logic violated the specified mapping while the user followed the documented API; the failure is in internal translation semantics.                                            | **C** — if user input is spec-conform and the internal bridge/translation violates the spec, classify as deep framework/compiler logic (C), not as a preventable usage/guard issue. |
