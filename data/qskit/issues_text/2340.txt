<!-- ⚠️ If you do not respect this template, your issue will be closed -->
<!-- ⚠️ Make sure to browse the opened and closed issues -->

### Informations

- **Qiskit Aer version**:
- 0.17.0
- **Python version**:
- Python 3.10.12
- **Operating system**:
- Linux (Ubuntu)

### What is the current behavior?
When using a gpu-enabled AerSimulator with blocking_enable=True and blocking_qubits < width of circuit, measurement samples can be seen corresponding to kets with 0 amplitude in the statevector.
The issue qualitatively seems to be more pronounced with "complicated" circuits, but can be reproduced consistently with very simple circuits.

### Steps to reproduce the problem

Run the following script with -b 2 in an environment with 2 GPUs.

```
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
import argparse
import numpy as np


parser = argparse.ArgumentParser()
parser.add_argument('-b', '--blocking', type=int, default=6)
args = parser.parse_args()

seed = 1    

backend_options = dict(
    method='statevector',
    device='GPU',
    cuStateVec_enable=True,
    precision='single'
)

backend_no_blocking = AerSimulator(**backend_options, blocking_enable=False, seed_simulator=seed)
backend_blocking = AerSimulator(**backend_options, blocking_enable=True, blocking_qubits=args.blocking, seed_simulator=seed)

N = 4

print(f'N={N}')

qc = QuantumCircuit(N)
for j in range(N-1):
    qc.h(j)

for j in range(N-1,0,-1):
    qc.mcx(list(range(j)), j)
qc.x(0)
    

t_qc_no_blocking = transpile(qc, backend_no_blocking, optimization_level=3, seed_transpiler=seed)
t_qc_no_blocking.save_statevector('final')
t_qc_no_blocking.measure_all()

t_qc_blocking = transpile(qc, backend_blocking, optimization_level=3, seed_transpiler=seed)
t_qc_blocking.save_statevector('final')
t_qc_blocking.measure_all()


expected_strings = ['0001','0010','0011','0100',
            '0101','0110','0111','1000']
expected_indexes = [1,2,3,4,5,6,7]

result_no_blocking = backend_no_blocking.run(t_qc_no_blocking, shots=10**7).result()
result_blocking = backend_blocking.run(t_qc_blocking, shots=10**7).result()

counts_no_blocking = result_no_blocking.get_counts()
counts_blocking = result_blocking.get_counts()

sv_no_blocking = result_no_blocking.data()['final'].data
sv_blocking = result_no_blocking.data()['final'].data

nz_no_blocking = np.nonzero(sv_no_blocking)
nz_blocking = np.nonzero(sv_blocking)

print('No blocking')
print(sv_no_blocking)
for index in nz_no_blocking[0]:
    if index not in expected_indexes:
        print(f'Rep: {np.binary_repr(index, qc.num_qubits)}. Amplitude: {np.abs(sv_no_blocking[index]) ** 2}')
for key in sorted(counts_no_blocking.keys()):
    if key not in expected_strings:
        print(f'key: {key}. count: {counts_no_blocking[key]}')


print('Blocking')
print(sv_blocking)
for index in nz_blocking[0]:
    if index not in expected_indexes:
        print(f'Rep: {np.binary_repr(index, qc.num_qubits)}. Amplitude: {np.abs(sv_no_blocking[index]) ** 2}')
for key in sorted(counts_blocking.keys()):
    if key not in expected_strings:
        print(f'key: {key}. count: {counts_blocking[key]}')
        
```

### What is the expected behavior?
The final statevector is  
[
  0, 0.35355335, 0.35355335, 0.35355335,
   0.35355335, 0.35355335, 0.35355335, 0.35355335, 
  0.35355335, 0, 0, 0,  
  0, 0, 0, 0
]
So measurement samples should be from the set {1,2,3,4,5,6,7}.

When cacheblocking is enabled and set to 2, there are unexpected samples of '0000'.


### Suggested solutions

Not sure. 

Note that in larger examples, I have seen unexpected samples of kets other than "all 0s".

Also, when running a large circuit (34 qubits, greater than 1 GPU on our environment) but setting blocking_qubits=34, the simulation returns almost immediately with all samples being "all 0s".
This is possibly an unrelated but might be linked! 