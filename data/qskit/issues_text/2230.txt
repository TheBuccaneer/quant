<!-- ⚠️ If you do not respect this template, your issue will be closed -->
<!-- ⚠️ Make sure to browse the opened and closed issues -->

[Benny](https://github.com/Bennybenassius) and I found this bug.

### Informations

- **Qiskit Aer version**: 0.15.0
- **Python version**: 3.11.6
- **Operating system**: Ubuntu 23.01 LTS

### What is the current behavior?
Runs indefinately

### Steps to reproduce the problem
Run this code:
``` py
from qiskit import QuantumCircuit, ClassicalRegister
from helpers.qiskit_helpers import compare_statevectors, run_on_simulator, run_routing_simulation

subcirc1 = QuantumCircuit(0)
# subcirc1.x(0)

main_circ = QuantumCircuit(1)
# Adding creg resources 
creg_0 = ClassicalRegister(1)
main_circ.add_register(creg_0)


main_circ.measure(0, creg_0[0])
main_circ.x(0)
with main_circ.if_test((creg_0[0],0)) as else_1:
    main_circ.append(subcirc1)
with else_1:
    main_circ.append(subcirc1)

main_circ.measure_active()
print(main_circ)
run_on_simulator(main_circ, 1)
```

Making the subroutine non-empty makes it work
``` py
from qiskit import QuantumCircuit, ClassicalRegister
from helpers.qiskit_helpers import compare_statevectors, run_on_simulator, run_routing_simulation

subcirc1 = QuantumCircuit(1)
subcirc1.x(0)

main_circ = QuantumCircuit(1)
# Adding creg resources 
creg_0 = ClassicalRegister(1)
main_circ.add_register(creg_0)


main_circ.measure(0, creg_0[0])
main_circ.x(0)
with main_circ.if_test((creg_0[0],0)) as else_1:
    main_circ.append(subcirc1, [0])
with else_1:
    main_circ.append(subcirc1, [0])

main_circ.measure_active()
print(main_circ)
run_on_simulator(main_circ, 1)
```

Moving the `x` gate before the measure makes it work
``` py
from qiskit import QuantumCircuit, ClassicalRegister
from helpers.qiskit_helpers import compare_statevectors, run_on_simulator, run_routing_simulation

subcirc1 = QuantumCircuit(0)

main_circ = QuantumCircuit(1)
# Adding creg resources 
creg_0 = ClassicalRegister(1)
main_circ.add_register(creg_0)

main_circ.x(0)
main_circ.measure(0, creg_0[0])

with main_circ.if_test((creg_0[0],0)) as else_1:
    main_circ.append(subcirc1)
with else_1:
    main_circ.append(subcirc1)

main_circ.measure_active()
print(main_circ)
run_on_simulator(main_circ, 1)
```

### What is the expected behavior?
Should return results, in the case of empty subroutine, should always treat it as identity 

### Suggested solutions

